{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Will Ware's portfolio website","text":"<p>I want to set up a portfolio website for my software engineering skills and interests.</p> <p>The portfolio should feel like you're stepping thru a science museum with wonders around every corner.</p> <p>It would be cool to have a local GitHub clone with pages and actions for CI/CD pipelines and documentation.</p> <p>Pages will be organized and rendered with MkDocs/Material/Mermaid, and eventually pushed to <code>wware.github.io</code> when ready.</p> <p>Borrow ideas from <code>eslam-abdo.github.io</code>. He did a nice job with some lovely effects.</p>"},{"location":"#mkdocs-commands","title":"MkDocs Commands","text":"<p>For full documentation visit mkdocs.org.</p> <ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs serve -a '0.0.0.0:8000'</code> if you want it available elsewhere on the LAN.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#mkdocs-material-docker-container","title":"Mkdocs-Material docker container","text":"<p>To make this work, I need to make a <code>Dockerfile</code> that does <code>pip install mkdocs-mermaid2-plugin</code> before building the docs and running the server.</p> <pre><code>docker run --rm -it -p 8000:8000 -v $(pwd):/docs squidfunk/mkdocs-material\n</code></pre>"},{"location":"api/","title":"APIs and Dynamic Content in MkDocs websites","text":""},{"location":"api/#prompt","title":"Prompt","text":"<p>I want to add a data API (probably json I guess) next to or inside my MkDocs website, probably using FastAPI. How would that be done? If I do that, can I use React in my Markdown source for dynamic UI stuff?</p> <p>Let's break down how you can add a data API using FastAPI to your MkDocs website and how you can integrate React for dynamic UI elements within your Markdown content.</p> <p>1. Setting up FastAPI alongside MkDocs</p> <p>You'll essentially run FastAPI as a separate application, but you'll need to configure it to work alongside your MkDocs site, ideally serving from the same domain or a subdomain.</p> <ul> <li> <p>Project Structure: <pre><code>my-mkdocs-project/\n\u251c\u2500\u2500 docs/          # Your Markdown content\n\u251c\u2500\u2500 mkdocs.yml    # MkDocs configuration\n\u251c\u2500\u2500 api/           # FastAPI application\n\u2502   \u251c\u2500\u2500 main.py    # FastAPI routes and logic\n\u2502   \u2514\u2500\u2500 ...       # Other FastAPI modules\n\u2514\u2500\u2500 ...\n</code></pre></p> </li> <li> <p>FastAPI Setup (api/main.py):</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n# CORS middleware (important for frontend communication)\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],  # Adjust this for production!\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\nclass Item(BaseModel):\n    name: str\n    value: int\n\n@app.get(\"/api/items\")\nasync def get_items():\n    items = [\n        {\"name\": \"Item 1\", \"value\": 10},\n        {\"name\": \"Item 2\", \"value\": 20},\n    ]\n    return items\n\n@app.post(\"/api/items\")\nasync def create_item(item: Item):\n    # Process the item (e.g., store it in a database)\n    return {\"message\": \"Item created\", \"item\": item}\n</code></pre> </li> <li> <p>Running FastAPI:</p> <pre><code>cd api\nuvicorn main:app --reload\n</code></pre> </li> <li> <p>Serving MkDocs and FastAPI together:</p> <ul> <li>Reverse Proxy (Recommended for Production): Use a web server like Nginx or Apache to reverse proxy requests to your MkDocs build and your FastAPI application.<ul> <li>Example Nginx configuration:     <pre><code>server {\n    listen 80;\n    server_name yourdomain.com; #or localhost\n\n    location / {\n        root /path/to/your/mkdocs/site; #the site folder created by mkdocs build.\n        index index.html;\n    }\n\n    location /api/ {\n        proxy_pass http://127.0.0.1:8000; #FastAPI port\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n</code></pre></li> </ul> </li> <li>Development: For development, you can run both separately and use CORS to allow communication between them.</li> </ul> </li> </ul> <p>2. Integrating React into Markdown with MkDocs</p> <p>While you can't directly embed React components into Markdown, you can achieve dynamic UI by:</p> <ul> <li> <p>Custom JavaScript:</p> <ul> <li>Add JavaScript to your MkDocs site that fetches data from your FastAPI API.</li> <li>Use this JavaScript to dynamically generate HTML elements and update them with the API data.</li> <li>You can include your javascript inside your <code>docs/javascripts</code> folder, and then add it to your <code>mkdocs.yml</code> file.</li> <li>Example javascript:     <pre><code>fetch('/api/items')\n    .then(response =&gt; response.json())\n    .then(data =&gt; {\n        const itemsContainer = document.getElementById('items-container');\n        if (itemsContainer) {\n            data.forEach(item =&gt; {\n                const itemElement = document.createElement('div');\n                itemElement.textContent = `${item.name}: ${item.value}`;\n                itemsContainer.appendChild(itemElement);\n            });\n        }\n    });\n</code></pre></li> <li>And in your markdown file:     <pre><code># Dynamic Items\n\n&lt;div id=\"items-container\"&gt;&lt;/div&gt;\n</code></pre></li> </ul> </li> <li> <p>Embedding React Build:</p> <ul> <li>Build your React application as a static bundle.</li> <li>Place the build output (HTML, CSS, JavaScript) in your <code>docs/</code> directory or a subdirectory.</li> <li>Link to the React application from your Markdown content using <code>&lt;iframe&gt;</code> or by creating links.</li> <li>For complex applications, this is often the best approach.</li> <li>You can serve the react build using the same webserver that serves the mkdocs files.</li> </ul> </li> <li>MkDocs Plugins:<ul> <li>Explore MkDocs plugins that might offer better integration with JavaScript or allow for custom HTML injection.</li> <li>There are not many plugins that will allow direct react injection, so the javascript or the build injection methods are the most common.</li> </ul> </li> </ul> <p>Important Considerations:</p> <ul> <li>CORS: Ensure your FastAPI application has appropriate CORS settings to allow requests from your MkDocs domain.</li> <li>Security: If your API handles sensitive data, implement proper authentication and authorization.</li> <li>Deployment: Consider how you'll deploy both your MkDocs site and your FastAPI application. Docker and container orchestration tools can simplify this process.</li> <li>Performance: Optimize your FastAPI API for performance, especially if it handles a large volume of requests.</li> <li>React Integration: If you are using React, consider how you will manage routing, state, and component communication when embedding it into your MkDocs site.</li> </ul> <p>By combining FastAPI for your data API and careful JavaScript or React integration, you can create a dynamic and interactive MkDocs website.</p>"},{"location":"api/#more-about-fastapi-and-mkdocs-integration","title":"More about FastAPI and MkDocs Integration","text":""},{"location":"api/#prompt_1","title":"Prompt","text":"<p>How to run <code>mkdocs serve</code> and FastAPI process together on the same port?</p>"},{"location":"api/#solution-implemented","title":"Solution Implemented","text":"<ol> <li>Modify FastAPI app to serve MkDocs content using StaticFiles</li> <li>Key code changes:    <pre><code>app.mount(\"/\", StaticFiles(directory=\"site\", html=True), name=\"site\")\n</code></pre></li> </ol>"},{"location":"api/#implementation-steps","title":"Implementation Steps","text":"<ol> <li>Build MkDocs site:    <pre><code>mkdocs build\n</code></pre></li> <li>Configure mkdocs.yml:    <pre><code>site_url: http://localhost:8000/\n</code></pre></li> <li>Run FastAPI application:    <pre><code>uvicorn api.main:app --reload\n</code></pre></li> </ol>"},{"location":"api/#result","title":"Result","text":"<ul> <li>API endpoints available at <code>/api/...</code></li> <li>Documentation served at root URL <code>/</code></li> <li>Single server handling both services</li> </ul>"},{"location":"api/#notes","title":"Notes","text":"<ul> <li>Remember to rebuild MkDocs when documentation changes</li> <li>Consider using file watcher or supervisor for development</li> <li>Production might benefit from reverse proxy setup</li> </ul>"},{"location":"auth/","title":"Passkeys and WebAuthn Authentication","text":"<p>Assume I have a website built with FastAPI. I want to add WebAuthn authentication but I'm new to that technology. Can you please explain it simply, what it looks like from the user's pov, and how to implement it on the server?</p>"},{"location":"auth/#webauthn-explained-simply","title":"WebAuthn Explained Simply","text":"<p>WebAuthn (Web Authentication) is a modern, secure way for users to log into websites without passwords. Instead, it uses \"authenticators\" like:</p> <ul> <li>Biometrics (fingerprint/face recognition)</li> <li>Security keys (like YubiKeys)</li> <li>Device-based authentication (like Windows Hello)</li> </ul> <p>These are either biometric or they depend on a piece of hardware.</p>"},{"location":"auth/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Registration Flow:</p> <ul> <li>Server creates a challenge and options</li> <li>Browser prompts user to use authenticator</li> <li>Server verifies and stores credential</li> </ul> </li> <li> <p>Login Flow:</p> <ul> <li>Server sends challenge and allowed credentials</li> <li>Browser prompts for authentication</li> <li>Server verifies and grants access</li> </ul> </li> <li> <p>Security Benefits:</p> <ul> <li>No passwords to steal or forget</li> <li>Resistant to phishing (domain verification)</li> <li>Protected by hardware/biometrics</li> </ul> </li> <li> <p>Implementation Notes:</p> <ul> <li>For production, use a proper database</li> <li>Add HTTPS (required in production)</li> <li>Consider user experience for different devices</li> </ul> </li> </ol>"},{"location":"auth/#from-a-users-perspective","title":"From a User's Perspective","text":"<p>When a user registers on your site with WebAuthn:</p> <ol> <li>They enter a username</li> <li>Instead of creating a password, they're prompted to use an authenticator (e.g., \"Touch your fingerprint sensor\")</li> <li>They complete the verification (touch fingerprint, insert security key, etc.)</li> <li>Registration complete!</li> </ol> <p>When they log in later:</p> <ol> <li>They enter their username</li> <li>They're prompted to use the same authenticator</li> <li>After verification, they're instantly logged in</li> </ol> <p>Users experience this as a quick, password-free login that feels more secure and convenient.</p>"},{"location":"auth/#implementing-webauthn-in-fastapi","title":"Implementing WebAuthn in FastAPI","text":""},{"location":"auth/#how-to-add-webauthn-to-your-fastapi-site","title":"How to add WebAuthn to your FastAPI site:","text":"Server side code in Python <pre><code>\"\"\"\nWebAuthn Implementation with FastAPI\n\nThis example demonstrates how to implement WebAuthn (Web Authentication) in a FastAPI application.\nIt provides endpoints for registration and authentication using WebAuthn.\n\"\"\"\n\nfrom fastapi import FastAPI, Request, HTTPException, Depends\nfrom fastapi.responses import JSONResponse, HTMLResponse\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.templating import Jinja2Templates\nimport webauthn\nfrom webauthn.helpers.structs import (\n    PublicKeyCredentialCreationOptions,\n    PublicKeyCredentialRequestOptions,\n    RegistrationCredential,\n    AuthenticationCredential,\n)\nfrom webauthn.helpers.cose import COSEAlgorithmIdentifier\nfrom pydantic import BaseModel\nimport base64\nimport json\nimport secrets\nfrom typing import Dict, Optional, List\nimport uuid\n\n# Initialize FastAPI\napp = FastAPI(title=\"FastAPI WebAuthn Example\")\n\n# This would be your database in a real application\nusers_db = {}\ncredentials_db = {}\n\n# Store challenges temporarily (in a real app, use Redis or similar)\nchallenge_db = {}\n\n# Configuration for your application\nRELYING_PARTY_ID = \"localhost\"  # Your domain name\nRELYING_PARTY_NAME = \"FastAPI WebAuthn Example\"\nRELYING_PARTY_ORIGIN = \"http://localhost:8000\"  # Your origin URL\n\n# Pydantic models for request validation\nclass RegisterStartRequest(BaseModel):\n    username: str\n\nclass RegisterCompleteRequest(BaseModel):\n    username: str\n    credential: dict\n\nclass LoginStartRequest(BaseModel):\n    username: str\n\nclass LoginCompleteRequest(BaseModel):\n    username: str\n    credential: dict\n\n# Utility functions\ndef generate_challenge() -&gt; str:\n    \"\"\"Generate a random challenge for WebAuthn operations\"\"\"\n    random_bytes = secrets.token_bytes(32)\n    return base64.urlsafe_b64encode(random_bytes).decode('utf-8').rstrip('=')\n\n# API Endpoints\n@app.post(\"/register/start\")\nasync def register_start(request: RegisterStartRequest):\n    \"\"\"Start the registration process\"\"\"\n    # Check if user already exists\n    if request.username in users_db:\n        raise HTTPException(status_code=400, detail=\"User already exists\")\n\n    # Generate a new user ID\n    user_id = str(uuid.uuid4())\n\n    # Store the user (in a real app, you'd save to a database)\n    users_db[request.username] = {\n        \"id\": user_id,\n        \"username\": request.username,\n        \"credentials\": []\n    }\n\n    # Generate a challenge\n    challenge = generate_challenge()\n    challenge_db[request.username] = challenge\n\n    # Create WebAuthn registration options\n    options = PublicKeyCredentialCreationOptions(\n        rp_id=RELYING_PARTY_ID,\n        rp_name=RELYING_PARTY_NAME,\n        user_id=user_id,\n        user_name=request.username,\n        user_display_name=request.username,\n        challenge=challenge,\n        pubkey_cred_params=[\n            {\"type\": \"public-key\", \"alg\": COSEAlgorithmIdentifier.ES256},\n            {\"type\": \"public-key\", \"alg\": COSEAlgorithmIdentifier.RS256},\n        ],\n        timeout=60000,\n        attestation=\"direct\",\n        authenticator_selection={\n            \"authenticator_attachment\": \"platform\",  # or \"cross-platform\" for security keys\n            \"require_resident_key\": False,\n            \"user_verification\": \"preferred\",\n        },\n        exclude_credentials=[],  # No credentials to exclude for a new user\n    )\n\n    return options.model_dump(mode=\"json\")\n\n@app.post(\"/register/complete\")\nasync def register_complete(request: RegisterCompleteRequest):\n    \"\"\"Complete the registration process\"\"\"\n    username = request.username\n\n    # Check if user exists\n    if username not in users_db:\n        raise HTTPException(status_code=400, detail=\"User does not exist\")\n\n    # Get the challenge\n    challenge = challenge_db.get(username)\n    if not challenge:\n        raise HTTPException(status_code=400, detail=\"No challenge found\")\n\n    # Parse the credential\n    try:\n        credential = RegistrationCredential.model_validate(request.credential)\n\n        # Verify the registration\n        registration_verification = webauthn.verify_registration_response(\n            credential=credential,\n            expected_challenge=challenge,\n            expected_origin=RELYING_PARTY_ORIGIN,\n            expected_rp_id=RELYING_PARTY_ID,\n            require_user_verification=False,\n        )\n\n        # Store the credential\n        credential_id = registration_verification.credential_id\n        public_key = registration_verification.credential_public_key\n\n        # In a real app, store these in a secure database\n        credentials_db[credential_id] = {\n            \"username\": username,\n            \"public_key\": public_key,\n            \"sign_count\": registration_verification.sign_count,\n        }\n\n        # Associate credential with user\n        users_db[username][\"credentials\"].append(credential_id)\n\n        # Clean up the challenge\n        del challenge_db[username]\n\n        return {\"status\": \"success\", \"message\": \"Registration successful\"}\n\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Registration failed: {str(e)}\")\n\n@app.post(\"/login/start\")\nasync def login_start(request: LoginStartRequest):\n    \"\"\"Start the login process\"\"\"\n    username = request.username\n\n    # Check if user exists\n    if username not in users_db:\n        raise HTTPException(status_code=400, detail=\"User does not exist\")\n\n    # Get user's credentials\n    user_credential_ids = users_db[username][\"credentials\"]\n    if not user_credential_ids:\n        raise HTTPException(status_code=400, detail=\"No credentials found for user\")\n\n    # Create a list of allowed credentials\n    allowed_credentials = []\n    for cred_id in user_credential_ids:\n        allowed_credentials.append({\n            \"type\": \"public-key\",\n            \"id\": cred_id,\n        })\n\n    # Generate a challenge\n    challenge = generate_challenge()\n    challenge_db[username] = challenge\n\n    # Create WebAuthn authentication options\n    options = PublicKeyCredentialRequestOptions(\n        challenge=challenge,\n        timeout=60000,\n        rp_id=RELYING_PARTY_ID,\n        allow_credentials=allowed_credentials,\n        user_verification=\"preferred\",\n    )\n\n    return options.model_dump(mode=\"json\")\n\n@app.post(\"/login/complete\")\nasync def login_complete(request: LoginCompleteRequest):\n    \"\"\"Complete the login process\"\"\"\n    username = request.username\n\n    # Check if user exists\n    if username not in users_db:\n        raise HTTPException(status_code=400, detail=\"User does not exist\")\n\n    # Get the challenge\n    challenge = challenge_db.get(username)\n    if not challenge:\n        raise HTTPException(status_code=400, detail=\"No challenge found\")\n\n    # Parse the credential\n    try:\n        credential = AuthenticationCredential.model_validate(request.credential)\n\n        # Get credential data\n        credential_id = credential.id\n        cred_data = credentials_db.get(credential_id)\n        if not cred_data or cred_data[\"username\"] != username:\n            raise HTTPException(status_code=400, detail=\"Invalid credential\")\n\n        # Verify the authentication\n        auth_verification = webauthn.verify_authentication_response(\n            credential=credential,\n            expected_challenge=challenge,\n            expected_origin=RELYING_PARTY_ORIGIN,\n            expected_rp_id=RELYING_PARTY_ID,\n            credential_public_key=cred_data[\"public_key\"],\n            credential_current_sign_count=cred_data[\"sign_count\"],\n            require_user_verification=False,\n        )\n\n        # Update the sign count\n        credentials_db[credential_id][\"sign_count\"] = auth_verification.new_sign_count\n\n        # Clean up the challenge\n        del challenge_db[username]\n\n        # In a real app, you would create a session or JWT token here\n\n        return {\"status\": \"success\", \"message\": \"Login successful\"}\n\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Authentication failed: {str(e)}\")\n\n# Serve a simple HTML page for testing\ntemplates = Jinja2Templates(directory=\"templates\")\n\n@app.get(\"/\", response_class=HTMLResponse)\nasync def read_root(request: Request):\n    return templates.TemplateResponse(\"index.html\", {\"request\": request})\n\n# Run the application with: uvicorn main:app --reload\n</code></pre>"},{"location":"auth/#sample-client-side-implementation","title":"Sample client-side implementation","text":"Client side code in HTML and JavaScript <pre><code>&lt;!-- \ntemplates/index.html\nThis is a simple client-side implementation of WebAuthn for your FastAPI application.\nPlace this file in a 'templates' directory in your FastAPI project.\n--&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;WebAuthn Example&lt;/title&gt;\n    &lt;style&gt;\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 800px;\n            margin: 0 auto;\n            padding: 20px;\n        }\n        .container {\n            display: flex;\n            justify-content: space-between;\n        }\n        .panel {\n            flex: 1;\n            margin: 10px;\n            padding: 20px;\n            border: 1px solid #ccc;\n            border-radius: 5px;\n        }\n        button {\n            margin-top: 10px;\n            padding: 8px 16px;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        input {\n            width: 100%;\n            padding: 8px;\n            margin-bottom: 10px;\n            box-sizing: border-box;\n        }\n        .status {\n            margin-top: 20px;\n            padding: 10px;\n            border-radius: 4px;\n        }\n        .success {\n            background-color: #dff0d8;\n            color: #3c763d;\n        }\n        .error {\n            background-color: #f2dede;\n            color: #a94442;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;WebAuthn Example&lt;/h1&gt;\n\n    &lt;div class=\"container\"&gt;\n        &lt;div class=\"panel\"&gt;\n            &lt;h2&gt;Register&lt;/h2&gt;\n            &lt;div&gt;\n                &lt;label for=\"register-username\"&gt;Username:&lt;/label&gt;\n                &lt;input type=\"text\" id=\"register-username\" placeholder=\"Enter username\"&gt;\n                &lt;button id=\"register-button\"&gt;Register&lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div id=\"register-status\" class=\"status\"&gt;&lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"panel\"&gt;\n            &lt;h2&gt;Login&lt;/h2&gt;\n            &lt;div&gt;\n                &lt;label for=\"login-username\"&gt;Username:&lt;/label&gt;\n                &lt;input type=\"text\" id=\"login-username\" placeholder=\"Enter username\"&gt;\n                &lt;button id=\"login-button\"&gt;Login&lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div id=\"login-status\" class=\"status\"&gt;&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n        // Helper functions for encoding/decoding base64url\n        function base64UrlToBuffer(base64Url) {\n            const padding = '='.repeat((4 - (base64Url.length % 4)) % 4);\n            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/') + padding;\n            const binary = window.atob(base64);\n            const buffer = new ArrayBuffer(binary.length);\n            const view = new Uint8Array(buffer);\n            for (let i = 0; i &lt; binary.length; i++) {\n                view[i] = binary.charCodeAt(i);\n            }\n            return buffer;\n        }\n\n        function bufferToBase64Url(buffer) {\n            const bytes = new Uint8Array(buffer);\n            let str = '';\n            for (const byte of bytes) {\n                str += String.fromCharCode(byte);\n            }\n            const base64 = window.btoa(str);\n            return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n        }\n\n        // ------ Registration Functions ------\n        async function startRegistration() {\n            const username = document.getElementById('register-username').value;\n            if (!username) {\n                updateStatus('register-status', 'Please enter a username', 'error');\n                return;\n            }\n\n            try {\n                // Call the registration start endpoint\n                const response = await fetch('/register/start', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                    },\n                    body: JSON.stringify({ username }),\n                });\n\n                if (!response.ok) {\n                    throw new Error(`Registration start failed: ${response.statusText}`);\n                }\n\n                // Get the options from the server\n                const options = await response.json();\n\n                // Convert base64url strings to ArrayBuffers\n                options.challenge = base64UrlToBuffer(options.challenge);\n                options.user.id = base64UrlToBuffer(options.user.id);\n                if (options.excludeCredentials) {\n                    for (const cred of options.excludeCredentials) {\n                        cred.id = base64UrlToBuffer(cred.id);\n                    }\n                }\n\n                // Create credentials\n                const credential = await navigator.credentials.create({\n                    publicKey: options\n                });\n\n                // Complete the registration\n                await completeRegistration(username, credential);\n\n            } catch (error) {\n                updateStatus('register-status', `Error: ${error.message}`, 'error');\n                console.error('Registration error:', error);\n            }\n        }\n\n        async function completeRegistration(username, credential) {\n            // Convert the credential to JSON\n            const credentialJSON = {\n                id: credential.id,\n                rawId: bufferToBase64Url(credential.rawId),\n                type: credential.type,\n                response: {\n                    clientDataJSON: bufferToBase64Url(credential.response.clientDataJSON),\n                    attestationObject: bufferToBase64Url(credential.response.attestationObject),\n                }\n            };\n\n            // Call the registration complete endpoint\n            const response = await fetch('/register/complete', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    username,\n                    credential: credentialJSON\n                }),\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(`Registration failed: ${errorData.detail || response.statusText}`);\n            }\n\n            const result = await response.json();\n            updateStatus('register-status', 'Registration successful!', 'success');\n        }\n\n        // ------ Login Functions ------\n        async function startLogin() {\n            const username = document.getElementById('login-username').value;\n            if (!username) {\n                updateStatus('login-status', 'Please enter a username', 'error');\n                return;\n            }\n\n            try {\n                // Call the login start endpoint\n                const response = await fetch('/login/start', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                    },\n                    body: JSON.stringify({ username }),\n                });\n\n                if (!response.ok) {\n                    throw new Error(`Login start failed: ${response.statusText}`);\n                }\n\n                // Get the options from the server\n                const options = await response.json();\n\n                // Convert base64url strings to ArrayBuffers\n                options.challenge = base64UrlToBuffer(options.challenge);\n                if (options.allowCredentials) {\n                    for (const cred of options.allowCredentials) {\n                        cred.id = base64UrlToBuffer(cred.id);\n                    }\n                }\n\n                // Get credentials\n                const credential = await navigator.credentials.get({\n                    publicKey: options\n                });\n\n                // Complete the login\n                await completeLogin(username, credential);\n\n            } catch (error) {\n                updateStatus('login-status', `Error: ${error.message}`, 'error');\n                console.error('Login error:', error);\n            }\n        }\n\n        async function completeLogin(username, credential) {\n            // Convert the credential to JSON\n            const credentialJSON = {\n                id: credential.id,\n                rawId: bufferToBase64Url(credential.rawId),\n                type: credential.type,\n                response: {\n                    clientDataJSON: bufferToBase64Url(credential.response.clientDataJSON),\n                    authenticatorData: bufferToBase64Url(credential.response.authenticatorData),\n                    signature: bufferToBase64Url(credential.response.signature),\n                    userHandle: credential.response.userHandle ? bufferToBase64Url(credential.response.userHandle) : null,\n                }\n            };\n\n            // Call the login complete endpoint\n            const response = await fetch('/login/complete', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    username,\n                    credential: credentialJSON\n                }),\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(`Login failed: ${errorData.detail || response.statusText}`);\n            }\n\n            const result = await response.json();\n            updateStatus('login-status', 'Login successful!', 'success');\n        }\n\n        // Helper function to update status messages\n        function updateStatus(elementId, message, type) {\n            const statusElement = document.getElementById(elementId);\n            statusElement.textContent = message;\n            statusElement.className = 'status ' + type;\n        }\n\n        // Add event listeners\n        document.addEventListener('DOMContentLoaded', function() {\n            document.getElementById('register-button').addEventListener('click', startRegistration);\n            document.getElementById('login-button').addEventListener('click', startLogin);\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"auth/#setting-up-your-project","title":"Setting Up Your Project","text":"<ol> <li>First, install required packages:</li> </ol> <pre><code>pip install fastapi uvicorn webauthn-python pydantic jinja2\n</code></pre> <ol> <li>Create the project structure:</li> </ol> <pre><code>your_project/\n\u251c\u2500\u2500 main.py            # FastAPI backend code\n\u2514\u2500\u2500 templates/\n    \u2514\u2500\u2500 index.html     # Frontend HTML/JS\n</code></pre> <ol> <li> <p>Copy the backend code to <code>main.py</code> and the frontend code to <code>templates/index.html</code>.</p> </li> <li> <p>Run the application:</p> </li> </ol> <pre><code>uvicorn main:app --reload\n</code></pre> <ol> <li>Visit <code>http://localhost:8000</code> in your browser to test.</li> </ol>"},{"location":"auth/#security-keys-more-than-just-storage","title":"Security Keys: More Than Just Storage","text":"<p>For a webauthn client that is not using biometrics, is there some hardware secret sauce required? or is it just the designated locus for the private key?</p> <p>Your question gets right to the heart of what makes WebAuthn security keys special. It's not just about storing the private key - there's indeed some \"hardware secret sauce\" involved.</p>"},{"location":"auth/#the-key-security-features","title":"The Key Security Features","text":"<p>Security keys (like YubiKeys, Google Titan keys, etc.) have several crucial security properties:</p> <ul> <li> <p>Secure Element: They contain a tamper-resistant secure element (specialized microchip) that:</p> <ul> <li>Generates and stores cryptographic keys</li> <li>Performs cryptographic operations inside the chip</li> <li>Prevents the private key from ever being exported or extracted</li> </ul> </li> <li> <p>User Presence Verification: The physical button/touch sensor isn't just for show:</p> <ul> <li>Ensures a human is present during each authentication</li> <li>Prevents remote malware from silently using the key</li> <li>Creates a physical action requirement for each authentication</li> </ul> </li> <li> <p>Counter Mechanism: Keys maintain an internal counter that:</p> <ul> <li>Increments with each use</li> <li>Helps detect cloned authenticators</li> <li>Allows servers to identify replay attacks</li> </ul> </li> <li> <p>Origin Binding: The key cryptographically ties authentication to specific websites:</p> <ul> <li>Prevents phishing by binding credentials to the correct domain</li> <li>Stops credentials generated for one site from being used on another</li> </ul> </li> </ul>"},{"location":"auth/#the-real-secret-sauce","title":"The Real \"Secret Sauce\"","text":"<p>The most important aspect is that the private key cannot be extracted - even by the device owner. All cryptographic operations happen inside the secure element. This means:</p> <ol> <li>The private key never leaves the device</li> <li>The key cannot be copied, backed up, or cloned</li> <li>Malware on your computer cannot access the key</li> <li>Even sophisticated hardware attacks are extremely difficult</li> </ol> <p>This hardware-enforced key isolation is what differentiates a WebAuthn security key from software-based approaches where private keys might be vulnerable to extraction.</p>"},{"location":"auth/#non-biometric-authentication-flow","title":"Non-Biometric Authentication Flow","text":"<p>Without biometrics, the authentication flow is:</p> <ol> <li>Website challenges the security key</li> <li>User proves physical presence by touching the key</li> <li>Key performs the cryptographic operation internally</li> <li>Key returns only the signed challenge (never the private key)</li> </ol> <p>So yes - the security key is far more than just a designated place to store a private key. It's a specialized cryptographic device with hardware-based security controls that create a trusted, phishing-resistant authentication mechanism.</p>"},{"location":"auth/#implementing-api-tokens-with-webauthn","title":"Implementing API Tokens with WebAuthn","text":"<p>Once a user has registered, I would like the server to be able to issue a time-limited API token which could be used by client side scripts that want to make API calls. Is that good security practice? How would that be implemented on the server side?</p> <p>Yes, issuing time-limited API tokens after WebAuthn authentication is a good security practice. This approach follows the principle of \"authenticate heavily once, then use lighter verification for a limited time\" - similar to how modern authentication systems work.</p>"},{"location":"auth/#security-benefits","title":"Security Benefits","text":"<ul> <li>Separation of concerns: Strong authentication (WebAuthn) is separate from API authorization (tokens)</li> <li>Limited exposure: Short-lived tokens reduce the risk if intercepted</li> <li>Revocable access: You can invalidate tokens if needed without requiring re-authentication</li> <li>Reduced authentication burden: Users don't need to repeatedly use their authenticator</li> </ul>"},{"location":"auth/#implementation-approach","title":"Implementation Approach","text":""},{"location":"auth/#server-side","title":"Server side","text":"Python code <pre><code>\"\"\"\nAPI Token Implementation with FastAPI and WebAuthn\n\nThis code extends the WebAuthn implementation to include API token generation,\nvalidation, and usage for authenticated users.\n\"\"\"\n\nfrom fastapi import FastAPI, Request, HTTPException, Depends, Header\nfrom fastapi.responses import JSONResponse\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nimport jwt\nfrom datetime import datetime, timedelta\nimport secrets\nfrom typing import Optional, Dict, List\nfrom pydantic import BaseModel\n\n# Include all the imports and WebAuthn code from the previous example\n# ...\n\n# Token configuration\nJWT_SECRET = secrets.token_urlsafe(32)  # Generate a secure random key for JWT signing\nTOKEN_ALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30  # Short-lived tokens for security\n\n# Token database (in a real app, use Redis or similar)\ntoken_blacklist = set()\n\n# Token models\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n    expires_at: datetime\n\nclass TokenData(BaseModel):\n    username: str\n    exp: datetime\n\n# OAuth2 scheme for token authentication\nsecurity = HTTPBearer()\n\n# Utility functions for tokens\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    \"\"\"Create a new JWT token with expiration time\"\"\"\n    to_encode = data.copy()\n\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, JWT_SECRET, algorithm=TOKEN_ALGORITHM)\n\n    return encoded_jwt, expire\n\ndef verify_token(token: str) -&gt; dict:\n    \"\"\"Verify a JWT token and return the payload\"\"\"\n    try:\n        # Check if token is blacklisted\n        if token in token_blacklist:\n            raise HTTPException(\n                status_code=401, \n                detail=\"Token has been revoked\"\n            )\n\n        # Decode and verify the token\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[TOKEN_ALGORITHM])\n        username = payload.get(\"sub\")\n\n        if username is None:\n            raise HTTPException(\n                status_code=401, \n                detail=\"Invalid token payload\"\n            )\n\n        # Check if user exists\n        if username not in users_db:\n            raise HTTPException(\n                status_code=401, \n                detail=\"User does not exist\"\n            )\n\n        return payload\n\n    except jwt.PyJWTError:\n        raise HTTPException(\n            status_code=401, \n            detail=\"Invalid token or token expired\"\n        )\n\nasync def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    \"\"\"Dependency to get the current user from a token\"\"\"\n    token = credentials.credentials\n    payload = verify_token(token)\n\n    username = payload.get(\"sub\")\n    return users_db.get(username)\n\n# Modified login endpoint to include token generation\n@app.post(\"/login/complete\")\nasync def login_complete(request: LoginCompleteRequest):\n    \"\"\"Complete the login process and return an access token\"\"\"\n    username = request.username\n\n    # Check if user exists\n    if username not in users_db:\n        raise HTTPException(status_code=400, detail=\"User does not exist\")\n\n    # Get the challenge\n    challenge = challenge_db.get(username)\n    if not challenge:\n        raise HTTPException(status_code=400, detail=\"No challenge found\")\n\n    # Parse the credential\n    try:\n        credential = AuthenticationCredential.model_validate(request.credential)\n\n        # Get credential data\n        credential_id = credential.id\n        cred_data = credentials_db.get(credential_id)\n        if not cred_data or cred_data[\"username\"] != username:\n            raise HTTPException(status_code=400, detail=\"Invalid credential\")\n\n        # Verify the authentication\n        auth_verification = webauthn.verify_authentication_response(\n            credential=credential,\n            expected_challenge=challenge,\n            expected_origin=RELYING_PARTY_ORIGIN,\n            expected_rp_id=RELYING_PARTY_ID,\n            credential_public_key=cred_data[\"public_key\"],\n            credential_current_sign_count=cred_data[\"sign_count\"],\n            require_user_verification=False,\n        )\n\n        # Update the sign count\n        credentials_db[credential_id][\"sign_count\"] = auth_verification.new_sign_count\n\n        # Clean up the challenge\n        del challenge_db[username]\n\n        # Generate access token\n        access_token, expire = create_access_token(\n            data={\"sub\": username},\n            expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n        )\n\n        return {\n            \"status\": \"success\", \n            \"message\": \"Login successful\",\n            \"access_token\": access_token,\n            \"token_type\": \"bearer\",\n            \"expires_at\": expire\n        }\n\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Authentication failed: {str(e)}\")\n\n# New token endpoints\n@app.post(\"/token/refresh\")\nasync def refresh_token(user = Depends(get_current_user)):\n    \"\"\"Generate a new token with a fresh expiration time\"\"\"\n    username = user[\"username\"]\n\n    # Generate a new access token\n    access_token, expire = create_access_token(\n        data={\"sub\": username},\n        expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    )\n\n    return {\n        \"access_token\": access_token,\n        \"token_type\": \"bearer\",\n        \"expires_at\": expire\n    }\n\n@app.post(\"/token/revoke\")\nasync def revoke_token(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    \"\"\"Revoke a token by adding it to the blacklist\"\"\"\n    token = credentials.credentials\n\n    # Verify the token is valid before revoking\n    verify_token(token)\n\n    # Add to blacklist\n    token_blacklist.add(token)\n\n    return {\"status\": \"success\", \"message\": \"Token revoked successfully\"}\n\n# Protected API route example\n@app.get(\"/api/protected-data\")\nasync def get_protected_data(user = Depends(get_current_user)):\n    \"\"\"Example protected API endpoint requiring a valid token\"\"\"\n    return {\n        \"status\": \"success\",\n        \"message\": f\"Hello {user['username']}, this is protected data\",\n        \"data\": {\n            \"secret_value\": \"This data is only accessible with a valid token\",\n            \"timestamp\": datetime.utcnow()\n        }\n    }\n\n# Sample API for listing user credentials (admin only in a real app)\n@app.get(\"/api/user/credentials\")\nasync def get_user_credentials(user = Depends(get_current_user)):\n    \"\"\"Get all credentials registered for the current user\"\"\"\n    username = user[\"username\"]\n\n    # Get credential IDs\n    credential_ids = users_db[username][\"credentials\"]\n\n    # Get credential details\n    credentials = []\n    for cred_id in credential_ids:\n        cred_data = credentials_db.get(cred_id)\n        if cred_data:\n            credentials.append({\n                \"id\": cred_id,\n                \"sign_count\": cred_data[\"sign_count\"],\n                # Don't include the public key in the response for security\n            })\n\n    return {\n        \"username\": username,\n        \"credential_count\": len(credentials),\n        \"credentials\": credentials\n    }\n</code></pre>"},{"location":"auth/#client-side","title":"Client side","text":"JavaScript code <pre><code>// Client-side JavaScript for handling API tokens\n// Add this to your index.html file\n\n// Token storage\nlet authToken = null;\nlet tokenExpiry = null;\n\n// Utility function to safely store tokens\nfunction storeToken(tokenData) {\n    // Store the token in memory (for this session)\n    authToken = tokenData.access_token;\n    tokenExpiry = new Date(tokenData.expires_at);\n\n    // Optional: Store in localStorage for persistent sessions\n    // Note: LocalStorage is vulnerable to XSS, so use with caution\n    localStorage.setItem('authToken', tokenData.access_token);\n    localStorage.setItem('tokenExpiry', tokenData.expires_at);\n\n    console.log(`Token stored. Expires at ${tokenExpiry}`);\n}\n\n// Check if token exists and is valid\nfunction hasValidToken() {\n    // If we don't have a token in memory, check localStorage\n    if (!authToken &amp;&amp; localStorage.getItem('authToken')) {\n        authToken = localStorage.getItem('authToken');\n        tokenExpiry = new Date(localStorage.getItem('tokenExpiry'));\n    }\n\n    // Check if we have a token and it's not expired\n    if (authToken &amp;&amp; tokenExpiry) {\n        // Add a 30-second buffer to ensure token isn't about to expire\n        const bufferTime = 30 * 1000; // 30 seconds in milliseconds\n        const now = new Date();\n        return now.getTime() + bufferTime &lt; tokenExpiry.getTime();\n    }\n\n    return false;\n}\n\n// Clear token on logout\nfunction clearToken() {\n    authToken = null;\n    tokenExpiry = null;\n    localStorage.removeItem('authToken');\n    localStorage.removeItem('tokenExpiry');\n}\n\n// Function to handle login and token acquisition\nasync function loginWithWebAuthn(username) {\n    try {\n        // Start the WebAuthn login process\n        const startResponse = await fetch('/login/start', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ username }),\n        });\n\n        if (!startResponse.ok) {\n            throw new Error(`Login start failed: ${startResponse.statusText}`);\n        }\n\n        const options = await startResponse.json();\n\n        // Convert base64url strings to ArrayBuffers\n        options.challenge = base64UrlToBuffer(options.challenge);\n        if (options.allowCredentials) {\n            for (const cred of options.allowCredentials) {\n                cred.id = base64UrlToBuffer(cred.id);\n            }\n        }\n\n        // Request the credential from the authenticator\n        const credential = await navigator.credentials.get({\n            publicKey: options\n        });\n\n        // Convert credential for sending to server\n        const credentialJSON = {\n            id: credential.id,\n            rawId: bufferToBase64Url(credential.rawId),\n            type: credential.type,\n            response: {\n                clientDataJSON: bufferToBase64Url(credential.response.clientDataJSON),\n                authenticatorData: bufferToBase64Url(credential.response.authenticatorData),\n                signature: bufferToBase64Url(credential.response.signature),\n                userHandle: credential.response.userHandle ? bufferToBase64Url(credential.response.userHandle) : null,\n            }\n        };\n\n        // Complete the login and get token\n        const completeResponse = await fetch('/login/complete', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n                username,\n                credential: credentialJSON\n            }),\n        });\n\n        if (!completeResponse.ok) {\n            const errorData = await completeResponse.json();\n            throw new Error(`Login failed: ${errorData.detail || completeResponse.statusText}`);\n        }\n\n        // Get the token and store it\n        const tokenData = await completeResponse.json();\n        storeToken(tokenData);\n\n        return {\n            success: true,\n            message: 'Login successful',\n            tokenData\n        };\n    } catch (error) {\n        console.error('Login error:', error);\n        return {\n            success: false,\n            message: error.message\n        };\n    }\n}\n\n// Function to make authenticated API requests\nasync function fetchWithAuth(url, options = {}) {\n    // Check if token is valid\n    if (!hasValidToken()) {\n        // No valid token, user needs to login again\n        throw new Error('No valid authentication token. Please login again.');\n    }\n\n    // Add Authorization header to request\n    const authOptions = {\n        ...options,\n        headers: {\n            ...options.headers,\n            'Authorization': `Bearer ${authToken}`\n        }\n    };\n\n    // Make the authenticated request\n    const response = await fetch(url, authOptions);\n\n    // Handle 401 Unauthorized (token expired or invalid)\n    if (response.status === 401) {\n        clearToken();\n        throw new Error('Authentication token expired or invalid. Please login again.');\n    }\n\n    return response;\n}\n\n// Sample function to refresh the token\nasync function refreshToken() {\n    try {\n        const response = await fetchWithAuth('/token/refresh', {\n            method: 'POST'\n        });\n\n        if (!response.ok) {\n            throw new Error('Failed to refresh token');\n        }\n\n        const tokenData = await response.json();\n        storeToken(tokenData);\n\n        return {\n            success: true,\n            message: 'Token refreshed successfully'\n        };\n    } catch (error) {\n        console.error('Token refresh error:', error);\n        return {\n            success: false,\n            message: error.message\n        };\n    }\n}\n\n// Sample function to logout and revoke token\nasync function logout() {\n    if (hasValidToken()) {\n        try {\n            // Revoke the token on the server\n            await fetchWithAuth('/token/revoke', {\n                method: 'POST'\n            });\n        } catch (error) {\n            console.error('Error revoking token:', error);\n        }\n    }\n\n    // Clear token from storage regardless of server response\n    clearToken();\n\n    return {\n        success: true,\n        message: 'Logged out successfully'\n    };\n}\n\n// Sample function to access a protected API endpoint\nasync function fetchProtectedData() {\n    try {\n        const response = await fetchWithAuth('/api/protected-data');\n\n        if (!response.ok) {\n            throw new Error(`API request failed: ${response.statusText}`);\n        }\n\n        return await response.json();\n    } catch (error) {\n        console.error('API request error:', error);\n        return {\n            success: false,\n            message: error.message\n        };\n    }\n}\n\n// Add event listeners for demo buttons\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Adding logout functionality\n    const logoutButton = document.createElement('button');\n    logoutButton.id = 'logout-button';\n    logoutButton.textContent = 'Logout';\n    logoutButton.addEventListener('click', async () =&gt; {\n        const result = await logout();\n        alert(result.message);\n        // Update UI to reflect logged out state\n        document.getElementById('token-info').textContent = 'Not logged in';\n        document.getElementById('protected-data').textContent = '';\n    });\n\n    // Button to fetch protected data\n    const dataButton = document.createElement('button');\n    dataButton.id = 'fetch-data-button';\n    dataButton.textContent = 'Fetch Protected Data';\n    dataButton.addEventListener('click', async () =&gt; {\n        try {\n            const data = await fetchProtectedData();\n            if (data.success !== false) {\n                document.getElementById('protected-data').textContent = \n                    JSON.stringify(data, null, 2);\n            } else {\n                alert(data.message);\n            }\n        } catch (error) {\n            alert('Error: ' + error.message);\n        }\n    });\n\n    // Add new elements to page\n    const container = document.querySelector('.container');\n\n    // Create API test panel\n    const apiPanel = document.createElement('div');\n    apiPanel.className = 'panel';\n    apiPanel.innerHTML = `\n        &lt;h2&gt;API Access&lt;/h2&gt;\n        &lt;div&gt;\n            &lt;p&gt;Token Status: &lt;span id=\"token-info\"&gt;Not logged in&lt;/span&gt;&lt;/p&gt;\n            &lt;div id=\"api-buttons\"&gt;&lt;/div&gt;\n            &lt;h3&gt;Protected Data:&lt;/h3&gt;\n            &lt;pre id=\"protected-data\"&gt;&lt;/pre&gt;\n        &lt;/div&gt;\n    `;\n\n    container.appendChild(apiPanel);\n    document.getElementById('api-buttons').appendChild(dataButton);\n    document.getElementById('api-buttons').appendChild(logoutButton);\n\n    // Update login success handler to also update token info\n    const originalLoginButton = document.getElementById('login-button');\n    originalLoginButton.removeEventListener('click', startLogin);\n    originalLoginButton.addEventListener('click', async () =&gt; {\n        const username = document.getElementById('login-username').value;\n        if (!username) {\n            updateStatus('login-status', 'Please enter a username', 'error');\n            return;\n        }\n\n        const result = await loginWithWebAuthn(username);\n        if (result.success) {\n            updateStatus('login-status', 'Login successful!', 'success');\n            document.getElementById('token-info').textContent = \n                `Logged in as ${username}. Token expires at ${new Date(result.tokenData.expires_at).toLocaleTimeString()}`;\n        } else {\n            updateStatus('login-status', `Error: ${result.message}`, 'error');\n        }\n    });\n\n    // Check for existing token on page load\n    if (hasValidToken()) {\n        document.getElementById('token-info').textContent = \n            `Token valid until ${tokenExpiry.toLocaleTimeString()}`;\n    }\n});\n</code></pre>"},{"location":"auth/#key-components-of-the-implementation","title":"Key Components of the Implementation","text":"<ul> <li> <p>Token Generation:</p> <ul> <li>After successful WebAuthn authentication, the server generates a JWT (JSON Web Token)</li> <li>The token contains the username and expiration time</li> <li>Tokens are signed with a secret key to prevent tampering</li> </ul> </li> <li> <p>Token Management:</p> <ul> <li>Storage: Client stores tokens in memory and optionally in localStorage</li> <li>Validation: Server verifies token signature and expiration</li> <li>Refresh: Client can request a new token before expiration</li> <li>Revocation: Server maintains a blacklist of revoked tokens</li> </ul> </li> <li> <p>API Security Flow:</p> <ul> <li>User authenticates with WebAuthn</li> <li>Server issues a short-lived token (30 minutes in the example)</li> <li>Client includes token in Authorization header for API requests</li> <li>Server validates token before processing the request</li> </ul> </li> </ul>"},{"location":"auth/#security-considerations","title":"Security Considerations","text":"<ul> <li> <p>Token Lifetime:</p> <ul> <li>Shorter lifetimes (15-60 minutes) are more secure</li> <li>Balance security with user experience</li> </ul> </li> <li> <p>Token Storage:</p> <ul> <li>Memory storage (variables) is cleared when page refreshes</li> <li>localStorage persists but is vulnerable to XSS attacks</li> <li>Consider using HttpOnly cookies as an alternative</li> </ul> </li> <li> <p>Token Revocation:</p> <ul> <li>Implement server-side blacklisting for immediate revocation</li> <li>For large-scale applications, use Redis or similar for blacklist storage</li> </ul> </li> <li> <p>JWT Claims:</p> <ul> <li>Include minimal necessary data (username/user ID)</li> <li>Add additional claims like IP address or device fingerprint for extra security</li> </ul> </li> </ul>"},{"location":"auth/#implementation-steps","title":"Implementation Steps","text":"<ol> <li> <p>Add the JWT package to your project:    <pre><code>pip install python-jose[cryptography]\n</code></pre></p> </li> <li> <p>Add the token generation to the login endpoint</p> </li> <li> <p>Add middleware or dependencies to validate tokens</p> </li> <li> <p>Create endpoints for token refresh and revocation</p> </li> <li> <p>Update your client-side code to manage tokens</p> </li> </ol> <p>This approach gives you a robust authentication system combining the security benefits of WebAuthn for initial authentication with the convenience of API tokens for continued access.</p>"},{"location":"auth/#setting-up-https-in-fastapi","title":"Setting Up HTTPS in FastAPI","text":"<p>Running FastAPI with HTTPS is essential for security, especially when implementing authentication like WebAuthn (which requires HTTPS except on localhost). Here's why:</p> <ol> <li>Data encryption between client and server</li> <li>Authentication of the server to clients</li> <li>Required for WebAuthn in production environments</li> <li>Protection against man-in-the-middle attacks</li> </ol>"},{"location":"auth/#option-1-using-uvicorn-with-ssl-certificates","title":"Option 1: Using Uvicorn with SSL Certificates","text":"<p>The simplest approach is running Uvicorn (the ASGI server for FastAPI) with SSL certificates:</p> <pre><code>uvicorn main:app --ssl-keyfile=./key.pem --ssl-certfile=./cert.pem\n</code></pre> <p>You'll need:</p> <ul> <li>key.pem: The private key file</li> <li>cert.pem: The SSL certificate file</li> </ul>"},{"location":"auth/#ssl-certificates-for-development","title":"SSL Certificates for Development","text":"<p>THIS IS FOR DEVELOPMENT ONLY! See notes about production below.</p> <p>For development, you can create self-signed certificates using OpenSSL. When running the OpenSSL commands, you'll be prompted for certificate information:</p> <ul> <li>Country Name (2 letter code)</li> <li>State or Province</li> <li>Locality Name (city)</li> <li>Organization Name</li> <li>Organizational Unit</li> <li>Common Name (IMPORTANT: use your domain name or localhost)</li> <li>Email Address</li> </ul> How to create self-signed certificates <pre><code>#!/bin/bash\n# Generate a private key\nopenssl genrsa -out key.pem 2048\n\n# Generate a certificate signing request (CSR)\nopenssl req -new -key key.pem -out csr.pem\n\n# Generate a self-signed certificate (valid for 365 days)\nopenssl x509 -req -days 365 -in csr.pem -signkey key.pem -out cert.pem\n\n# Clean up the CSR file\nrm csr.pem\n\necho \"Self-signed certificate generated:\"\necho \"Private key: key.pem\"\necho \"Certificate: cert.pem\"\n</code></pre>"},{"location":"auth/#ssl-certificates-for-production","title":"SSL Certificates for Production","text":"<p>For a production environment, you'll want to obtain trusted SSL certificates that browsers will recognize without security warnings. Here are the best options:</p>"},{"location":"auth/#lets-encrypt-recommended","title":"Let's Encrypt (Recommended)","text":"<p>Let's Encrypt is a free, automated, and open certificate authority that provides trusted SSL certificates.</p> <ul> <li>Completely free</li> <li>Automated renewal process</li> <li>Trusted by all major browsers</li> <li>Easy to set up</li> </ul> <p>How to get Let's Encrypt certificates:</p> <ol> <li> <p>Install Certbot:    <pre><code># On Ubuntu/Debian\nsudo apt-get update\nsudo apt-get install certbot\n\n# For Nginx\nsudo apt-get install python3-certbot-nginx\n\n# For Apache\nsudo apt-get install python3-certbot-apache\n</code></pre></p> </li> <li> <p>Generate certificates:    <pre><code># With Nginx\nsudo certbot --nginx -d yourdomain.com -d www.yourdomain.com\n\n# With Apache\nsudo certbot --apache -d yourdomain.com -d www.yourdomain.com\n\n# Standalone (if no web server is running)\nsudo certbot certonly --standalone -d yourdomain.com -d www.yourdomain.com\n</code></pre></p> </li> <li> <p>Set up auto-renewal:    <pre><code># Test auto-renewal\nsudo certbot renew --dry-run\n\n# Certbot installs a cron job or systemd timer automatically\n</code></pre></p> </li> </ol>"},{"location":"auth/#commercial-certificate-authorities","title":"Commercial Certificate Authorities","text":"<p>If you prefer a paid option (often with extended validation or additional features):</p> <ol> <li>DigiCert: Premium certificates with high browser trust</li> <li>Sectigo (formerly Comodo): Cost-effective with multi-domain options</li> <li>GlobalSign: Good for enterprise with managed services</li> <li>GoDaddy: Popular with good integration if you already use their services</li> </ol> <p>These typically cost $50-300 per year depending on the validation level and features.</p>"},{"location":"auth/#cloud-provider-certificates","title":"Cloud Provider Certificates","text":"<p>If your application is hosted with a cloud provider:</p> <ol> <li>AWS Certificate Manager: Free SSL certificates for AWS services</li> <li>Google Cloud Certificate Manager: Free SSL certificates with Google Cloud</li> <li>Azure App Service: Free certificates for Azure-hosted services</li> </ol>"},{"location":"auth/#domain-registrar-certificates","title":"Domain Registrar Certificates","text":"<p>Many domain registrars now offer free or inexpensive SSL certificates:</p> <ol> <li>Cloudflare: Free SSL with their CDN service</li> <li>Namecheap: Affordable certificates bundled with domain registration</li> </ol>"},{"location":"auth/#important-considerations-for-production","title":"Important Considerations for Production","text":"<ol> <li>Validity period: Let's Encrypt certificates last 90 days and must be renewed</li> <li>Automation: Set up automatic renewal to avoid expiration</li> <li>Certificate chain: Ensure the full chain is included</li> <li>Key security: Keep your private keys secure</li> <li>Monitoring: Set up monitoring for certificate expiration</li> </ol> <p>For most applications, Let's Encrypt is the ideal solution due to its ease of use, zero cost, and automated renewal process. The certificates are trusted by all major browsers and provide the same level of encryption as paid certificates.</p>"},{"location":"auth/#option-2-using-fastapi-with-https-in-production-code","title":"Option 2: Using FastAPI with HTTPS in Production Code","text":"<p>For more production-ready code, you can configure HTTPS directly in your application:</p> FastAPI HTTPS configuration <pre><code>\"\"\"\nHTTPS Configuration for FastAPI\n\nThis script demonstrates how to run FastAPI with HTTPS enabled\nusing Uvicorn programmatically.\n\"\"\"\n\nimport uvicorn\nfrom fastapi import FastAPI\nimport os\nimport argparse\n\n# Create the FastAPI app\napp = FastAPI()\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello, HTTPS World!\"}\n\n@app.get(\"/secure\")\nasync def secure_endpoint():\n    return {\"message\": \"This endpoint is secure!\"}\n\nif __name__ == \"__main__\":\n    # Set up command line arguments\n    parser = argparse.ArgumentParser(description=\"Run FastAPI with HTTPS\")\n    parser.add_argument(\"--host\", default=\"0.0.0.0\", help=\"Host to bind to\")\n    parser.add_argument(\"--port\", type=int, default=8443, help=\"Port to bind to\")\n    parser.add_argument(\n        \"--ssl-keyfile\", \n        default=\"./key.pem\", \n        help=\"SSL key file path\"\n    )\n    parser.add_argument(\n        \"--ssl-certfile\", \n        default=\"./cert.pem\", \n        help=\"SSL certificate file path\"\n    )\n    parser.add_argument(\n        \"--reload\", \n        action=\"store_true\", \n        help=\"Enable auto-reload for development\"\n    )\n    args = parser.parse_args()\n\n    # Verify SSL files exist\n    if not os.path.isfile(args.ssl_keyfile):\n        raise FileNotFoundError(f\"SSL key file not found: {args.ssl_keyfile}\")\n    if not os.path.isfile(args.ssl_certfile):\n        raise FileNotFoundError(f\"SSL certificate file not found: {args.ssl_certfile}\")\n\n    # Configure and run Uvicorn with SSL\n    uvicorn.run(\n        \"main:app\",  # Replace with the actual path to your app\n        host=args.host,\n        port=args.port,\n        ssl_keyfile=args.ssl_keyfile,\n        ssl_certfile=args.ssl_certfile,\n        reload=args.reload\n    )\n\n    # Run with:\n    # python main.py --port=8443 --ssl-keyfile=./key.pem --ssl-certfile=./cert.pem\n</code></pre>"},{"location":"auth/#option-3-production-setup-with-reverse-proxy","title":"Option 3: Production Setup with Reverse Proxy","text":"<p>For production environments, the recommended approach is to use a reverse proxy:</p> Nginx reverse proxy configuration <pre><code># /etc/nginx/sites-available/fastapi-app\n\nserver {\n    # Listen on port 80 and redirect to HTTPS\n    listen 80;\n    server_name yourdomain.com www.yourdomain.com;\n\n    # Redirect all HTTP requests to HTTPS\n    location / {\n        return 301 https://$host$request_uri;\n    }\n}\n\nserver {\n    # Listen on port 443 for HTTPS connections\n    listen 443 ssl http2;\n    server_name yourdomain.com www.yourdomain.com;\n\n    # SSL certificate configuration\n    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;\n\n    # Modern SSL configuration\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_prefer_server_ciphers off;\n    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;\n\n    # SSL session settings\n    ssl_session_timeout 1d;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_tickets off;\n\n    # HSTS (optional, but recommended)\n    add_header Strict-Transport-Security \"max-age=63072000\" always;\n\n    # OCSP Stapling\n    ssl_stapling on;\n    ssl_stapling_verify on;\n    resolver 8.8.8.8 8.8.4.4 valid=300s;\n    resolver_timeout 5s;\n\n    # Proxy settings\n    location / {\n        proxy_pass http://localhost:8000;  # Your FastAPI app running on port 8000\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n</code></pre>"},{"location":"auth/#setting-up-https-in-production-recommended-steps","title":"Setting Up HTTPS in Production: Recommended Steps","text":"<ol> <li> <p>Get a Real Certificate:</p> <ul> <li>Use Let's Encrypt for free TLS certificates:     <pre><code>sudo apt-get install certbot\nsudo certbot certonly --standalone -d yourdomain.com\n</code></pre></li> <li>This generates certificates in <code>/etc/letsencrypt/live/yourdomain.com/</code></li> </ul> </li> <li> <p>Set Up Nginx as Reverse Proxy:</p> <ul> <li>Install Nginx: <code>sudo apt-get install nginx</code></li> <li>Create a config file (see \"Nginx reverse proxy configuration\" above)</li> <li>Enable the site: <code>sudo ln -s /etc/nginx/sites-available/fastapi-app /etc/nginx/sites-enabled/</code></li> <li>Test and restart: <code>sudo nginx -t &amp;&amp; sudo systemctl restart nginx</code></li> </ul> </li> <li> <p>Run FastAPI Without SSL:</p> <ul> <li>Let Nginx handle SSL/TLS</li> <li>Run FastAPI internally: <code>uvicorn main:app --host 127.0.0.1 --port 8000</code></li> </ul> </li> <li> <p>Set Up as a Service (using systemd):</p> <p> FastAPI systemd service configuration <p><pre><code># /etc/systemd/system/fastapi.service\n\n[Unit]\nDescription=FastAPI application\nAfter=network.target\n\n[Service]\nUser=yourusername\nGroup=yourusername\nWorkingDirectory=/path/to/your/app\nExecStart=/path/to/your/venv/bin/uvicorn main:app --host 127.0.0.1 --port 8000\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> </p> <p>Then enable and start the service: <pre><code>sudo systemctl enable fastapi\nsudo systemctl start fastapi\n</code></pre></p>"},{"location":"auth/#local-development-with-https","title":"Local Development with HTTPS","text":"<p>For local development with HTTPS:</p> <ol> <li>Generate self-signed certificates (see the script above)</li> <li>Run with SSL options:    <pre><code>uvicorn main:app --ssl-keyfile=./key.pem --ssl-certfile=./cert.pem\n</code></pre></li> <li>Accept the security warning in your browser (or add an exception)</li> </ol> <p>Remember that for WebAuthn development, you can use <code>localhost</code> without HTTPS, but any other domain requires HTTPS.</p>"},{"location":"auth/#best-practices-for-https-in-production","title":"Best Practices for HTTPS in Production","text":"<ol> <li>Use a Reverse Proxy (Nginx/Apache) to handle SSL termination</li> <li>Auto-renew certificates using Let's Encrypt's certbot</li> <li>Implement HSTS (HTTP Strict Transport Security)</li> <li>Configure strong ciphers for optimal security</li> <li>Use HTTP/2 for better performance</li> <li>Test your SSL configuration with tools like SSL Labs</li> </ol>"},{"location":"auth/#understanding-jwt-in-webauthn","title":"Understanding JWT in WebAuthn","text":"<p>JSON Web Token plays an important complementary role in WebAuthn implementations.</p>"},{"location":"auth/#what-is-jwt","title":"What is JWT?","text":"<p>JWT (JSON Web Token) is a compact, self-contained way to securely transmit information between parties as a JSON object. This information is digitally signed, so it can be verified and trusted. JWTs are commonly used for:</p> <ol> <li>Authentication: After a user logs in</li> <li>Information Exchange: Securely transferring data between parties</li> <li>Authorization: Controlling what resources a user can access</li> </ol> <p>A JWT consists of three parts separated by dots: - Header: Specifies the token type and signing algorithm - Payload: Contains the claims (data) - Signature: Ensures the token hasn't been altered</p>"},{"location":"auth/#jwts-role-in-webauthn","title":"JWT's Role in WebAuthn","text":"<p>In a WebAuthn implementation, JWT serves a different purpose than WebAuthn itself:</p>"},{"location":"auth/#webauthns-role","title":"WebAuthn's Role:","text":"<ul> <li>Handles the initial authentication (proving who you are)</li> <li>Uses cryptographic keys stored in hardware</li> <li>Provides strong authentication without passwords</li> <li>Tied to the specific origin (website)</li> </ul>"},{"location":"auth/#jwts-role","title":"JWT's Role:","text":"<ul> <li>Handles authorization (what you can access)</li> <li>Maintains user session after authentication</li> <li>Carries identity information across API calls</li> <li>Enables stateless communication between client and server</li> </ul>"},{"location":"auth/#typical-flow-in-a-webauthn-jwt-system","title":"Typical Flow in a WebAuthn + JWT System","text":"<ol> <li> <p>User Authentication with WebAuthn:</p> <ul> <li>User proves identity using biometrics/security key</li> <li>Server verifies the cryptographic proof</li> </ul> </li> <li> <p>JWT Issuance:</p> <ul> <li>Upon successful WebAuthn authentication, server generates a JWT</li> <li>JWT contains user identity and permissions</li> <li>Server signs the JWT with its secret key</li> </ul> </li> <li> <p>API Access with JWT:</p> <ul> <li>Client includes JWT in subsequent API requests</li> <li>Server validates JWT signature and expiration</li> <li>Server grants access based on claims in the JWT</li> </ul> </li> <li> <p>Token Renewal:</p> <ul> <li>Client can request a new JWT before expiration</li> <li>May require re-authentication with WebAuthn for security</li> </ul> </li> </ol>"},{"location":"auth/#benefits-of-combining-webauthn-and-jwt","title":"Benefits of Combining WebAuthn and JWT","text":"<ul> <li> <p>Separation of Concerns:</p> <ul> <li>WebAuthn handles secure authentication</li> <li>JWT handles ongoing authorization</li> </ul> </li> <li> <p>Improved UX:</p> <ul> <li>User only needs to perform WebAuthn authentication occasionally</li> <li>JWT provides smooth access between authentications</li> </ul> </li> <li> <p>Scalability:</p> <ul> <li>JWT enables stateless authentication for APIs</li> <li>Reduces database lookups for session validation</li> </ul> </li> <li> <p>Security Layers:</p> <ul> <li>WebAuthn provides phishing-resistant initial auth</li> <li>Short-lived JWTs limit the impact of token theft</li> </ul> </li> </ul>"},{"location":"auth/#implementation-considerations","title":"Implementation Considerations","text":"<ul> <li>Token Lifetime: Shorter lifetimes (15-60 minutes) improve security</li> <li>Token Storage: Store JWT securely (memory for SPA, HttpOnly cookies for web apps)</li> <li>Claims: Include only necessary data (user ID, roles, permissions)</li> <li>Refresh Strategy: Consider using refresh tokens for longer sessions</li> <li>Revocation: Implement token blacklisting for compromised tokens</li> </ul> <p>In essence, WebAuthn and JWT work together to create a complete authentication and authorization system \u2013 WebAuthn provides strong initial identity verification, while JWT provides the ongoing session management and API access authorization.</p>"},{"location":"auth/#maybe-use-google-authenticator-instead","title":"Maybe use Google Authenticator instead?","text":"<p>Google Authenticator provides weaker security, and the user experience is more burdensome.</p> <p>Google Authenticator is a Time-based One-Time Password (TOTP) solution that works differently from WebAuthn:</p>"},{"location":"auth/#google-authenticator","title":"Google Authenticator:","text":"<ul> <li>How it works: Generates time-based codes that change every 30 seconds</li> <li>User experience: User manually enters a 6-digit code</li> <li>Setup: Requires scanning a QR code or entering a secret key</li> <li>Portability: Works across any device that has the app</li> <li>Authentication flow: Still requires username/password PLUS the code</li> </ul>"},{"location":"auth/#webauthn","title":"WebAuthn:","text":"<ul> <li>How it works: Uses public-key cryptography with physical authenticators</li> <li>User experience: User interacts with biometrics or security key</li> <li>Setup: Uses device's built-in authenticator capabilities</li> <li>Portability: May require registering multiple devices</li> <li>Authentication flow: Can completely replace passwords</li> </ul>"},{"location":"auth/#implementation-with-google-authenticator","title":"Implementation with Google Authenticator","text":"<p>Here's what you would need to implement Google Authenticator with API tokens.</p>"},{"location":"auth/#server-side_1","title":"Server side","text":"Python code <pre><code>\"\"\"\nGoogle Authenticator (TOTP) Implementation with FastAPI and JWT tokens\n\nThis implementation demonstrates how to use Google Authenticator with FastAPI\nand issue API tokens upon successful authentication.\n\"\"\"\n\nfrom fastapi import FastAPI, Request, HTTPException, Depends, Header\nfrom fastapi.responses import JSONResponse\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom fastapi.templating import Jinja2Templates\nfrom pydantic import BaseModel\nimport pyotp\nimport qrcode\nimport io\nimport base64\nimport jwt\nfrom datetime import datetime, timedelta\nimport secrets\nfrom typing import Optional, Dict\nimport uuid\n\napp = FastAPI(title=\"FastAPI Google Authenticator Example\")\n\n# This would be your database in a real application\nusers_db = {}\ntotp_secrets = {}\n\n# Token configuration\nJWT_SECRET = secrets.token_urlsafe(32)\nTOKEN_ALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\ntoken_blacklist = set()\n\n# OAuth2 scheme for token authentication\nsecurity = HTTPBearer()\ntemplates = Jinja2Templates(directory=\"templates\")\n\n# Pydantic models\nclass UserRegistration(BaseModel):\n    username: str\n    password: str  # In real app, you'd hash this\n\nclass TOTPVerification(BaseModel):\n    username: str\n    password: str\n    totp_code: str\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n    expires_at: datetime\n\n# Token utilities (same as WebAuthn example)\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    \"\"\"Create a new JWT token with expiration time\"\"\"\n    to_encode = data.copy()\n\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, JWT_SECRET, algorithm=TOKEN_ALGORITHM)\n\n    return encoded_jwt, expire\n\ndef verify_token(token: str) -&gt; dict:\n    \"\"\"Verify a JWT token and return the payload\"\"\"\n    try:\n        if token in token_blacklist:\n            raise HTTPException(status_code=401, detail=\"Token has been revoked\")\n\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[TOKEN_ALGORITHM])\n        username = payload.get(\"sub\")\n\n        if username is None or username not in users_db:\n            raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n        return payload\n\n    except jwt.PyJWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid token or token expired\")\n\nasync def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    \"\"\"Dependency to get the current user from a token\"\"\"\n    token = credentials.credentials\n    payload = verify_token(token)\n\n    username = payload.get(\"sub\")\n    return users_db.get(username)\n\n# User registration\n@app.post(\"/register\")\nasync def register_user(user: UserRegistration):\n    \"\"\"Register a new user and generate a TOTP secret\"\"\"\n    username = user.username\n\n    # Check if user already exists\n    if username in users_db:\n        raise HTTPException(status_code=400, detail=\"User already exists\")\n\n    # Generate a unique user ID\n    user_id = str(uuid.uuid4())\n\n    # Generate a TOTP secret\n    totp_secret = pyotp.random_base32()\n\n    # Create TOTP object\n    totp = pyotp.TOTP(totp_secret)\n\n    # Store user (in a real app, you'd hash the password)\n    users_db[username] = {\n        \"id\": user_id,\n        \"username\": username,\n        \"password\": user.password\n    }\n\n    # Store TOTP secret\n    totp_secrets[username] = totp_secret\n\n    # Generate QR code for Google Authenticator\n    provisioning_uri = totp.provisioning_uri(\n        name=username,\n        issuer_name=\"FastAPI TOTP Example\"\n    )\n\n    # Create QR code image\n    qr = qrcode.QRCode(\n        version=1,\n        error_correction=qrcode.constants.ERROR_CORRECT_L,\n        box_size=10,\n        border=4,\n    )\n    qr.add_data(provisioning_uri)\n    qr.make(fit=True)\n\n    img = qr.make_image(fill_color=\"black\", back_color=\"white\")\n\n    # Convert image to base64 for embedding in HTML\n    buffered = io.BytesIO()\n    img.save(buffered)\n    img_str = base64.b64encode(buffered.getvalue()).decode()\n\n    return {\n        \"status\": \"success\",\n        \"message\": \"User registered successfully\",\n        \"totp_secret\": totp_secret,  # In a real app, don't return this directly\n        \"qr_code\": f\"data:image/png;base64,{img_str}\",\n        \"setup_instructions\": \"Scan this QR code with Google Authenticator app\"\n    }\n\n# Verify TOTP and get token\n@app.post(\"/login\")\nasync def verify_totp(verification: TOTPVerification):\n    \"\"\"Verify TOTP code and issue an access token\"\"\"\n    username = verification.username\n    password = verification.password\n    totp_code = verification.totp_code\n\n    # Check if user exists\n    if username not in users_db:\n        raise HTTPException(status_code=400, detail=\"User does not exist\")\n\n    # Verify password (in a real app, you'd verify hashed password)\n    if users_db[username][\"password\"] != password:\n        raise HTTPException(status_code=401, detail=\"Invalid credentials\")\n\n    # Check if user has TOTP secret\n    if username not in totp_secrets:\n        raise HTTPException(status_code=400, detail=\"TOTP not set up for user\")\n\n    # Verify TOTP code\n    totp = pyotp.TOTP(totp_secrets[username])\n    if not totp.verify(totp_code):\n        raise HTTPException(status_code=401, detail=\"Invalid TOTP code\")\n\n    # Generate access token\n    access_token, expire = create_access_token(\n        data={\"sub\": username},\n        expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    )\n\n    return {\n        \"status\": \"success\",\n        \"message\": \"Authentication successful\",\n        \"access_token\": access_token,\n        \"token_type\": \"bearer\",\n        \"expires_at\": expire\n    }\n\n# Token refresh endpoint\n@app.post(\"/token/refresh\")\nasync def refresh_token(user = Depends(get_current_user)):\n    \"\"\"Generate a fresh token with new expiration\"\"\"\n    username = user[\"username\"]\n\n    access_token, expire = create_access_token(\n        data={\"sub\": username},\n        expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    )\n\n    return {\n        \"access_token\": access_token,\n        \"token_type\": \"bearer\",\n        \"expires_at\": expire\n    }\n\n# Token revocation endpoint\n@app.post(\"/token/revoke\")\nasync def revoke_token(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    \"\"\"Revoke a token by adding it to the blacklist\"\"\"\n    token = credentials.credentials\n\n    # Verify the token is valid\n    verify_token(token)\n\n    # Add to blacklist\n    token_blacklist.add(token)\n\n    return {\"status\": \"success\", \"message\": \"Token revoked successfully\"}\n\n# Protected API endpoint example\n@app.get(\"/api/protected-data\")\nasync def get_protected_data(user = Depends(get_current_user)):\n    \"\"\"Example of a protected API endpoint\"\"\"\n    return {\n        \"status\": \"success\",\n        \"message\": f\"Hello {user['username']}, this is protected data\",\n        \"data\": {\n            \"secret_value\": \"This data is only accessible with a valid token\",\n            \"timestamp\": datetime.utcnow()\n        }\n    }\n\n# Simple HTML page for testing\n@app.get(\"/\")\nasync def read_root(request: Request):\n    return templates.TemplateResponse(\"totp_index.html\", {\"request\": request})\n</code></pre>"},{"location":"auth/#client-side_1","title":"Client side","text":"HTML, JavaScript <pre><code>&lt;!-- \n  templates/totp_index.html\n  This is a simple client-side implementation for Google Authenticator TOTP with FastAPI.\n  Place this file in a 'templates' directory in your FastAPI project.\n--&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Google Authenticator Example&lt;/title&gt;\n    &lt;style&gt;\n        body {\n            font-family: Arial, sans-serif;\n            max-width: 800px;\n            margin: 0 auto;\n            padding: 20px;\n        }\n        .container {\n            display: flex;\n            flex-wrap: wrap;\n            justify-content: space-between;\n        }\n        .panel {\n            flex: 1;\n            min-width: 300px;\n            margin: 10px;\n            padding: 20px;\n            border: 1px solid #ccc;\n            border-radius: 5px;\n        }\n        button {\n            margin-top: 10px;\n            padding: 8px 16px;\n            background-color: #4CAF50;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        }\n        button:hover {\n            background-color: #45a049;\n        }\n        input {\n            width: 100%;\n            padding: 8px;\n            margin-bottom: 10px;\n            box-sizing: border-box;\n        }\n        .qr-code {\n            margin-top: 20px;\n            text-align: center;\n        }\n        .qr-code img {\n            max-width: 200px;\n        }\n        .status {\n            margin-top: 20px;\n            padding: 10px;\n            border-radius: 4px;\n        }\n        .success {\n            background-color: #dff0d8;\n            color: #3c763d;\n        }\n        .error {\n            background-color: #f2dede;\n            color: #a94442;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Google Authenticator Example&lt;/h1&gt;\n\n    &lt;div class=\"container\"&gt;\n        &lt;div class=\"panel\"&gt;\n            &lt;h2&gt;Register&lt;/h2&gt;\n            &lt;div&gt;\n                &lt;label for=\"register-username\"&gt;Username:&lt;/label&gt;\n                &lt;input type=\"text\" id=\"register-username\" placeholder=\"Enter username\"&gt;\n\n                &lt;label for=\"register-password\"&gt;Password:&lt;/label&gt;\n                &lt;input type=\"password\" id=\"register-password\" placeholder=\"Enter password\"&gt;\n\n                &lt;button id=\"register-button\"&gt;Register&lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div id=\"register-status\" class=\"status\"&gt;&lt;/div&gt;\n            &lt;div id=\"qr-container\" class=\"qr-code\" style=\"display: none;\"&gt;\n                &lt;h3&gt;Scan this QR code with Google Authenticator&lt;/h3&gt;\n                &lt;img id=\"qr-code\" src=\"\" alt=\"QR Code\"&gt;\n                &lt;p&gt;Please save this QR code or secret key. You won't be able to see it again!&lt;/p&gt;\n                &lt;p&gt;Secret key: &lt;span id=\"totp-secret\"&gt;&lt;/span&gt;&lt;/p&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"panel\"&gt;\n            &lt;h2&gt;Login&lt;/h2&gt;\n            &lt;div&gt;\n                &lt;label for=\"login-username\"&gt;Username:&lt;/label&gt;\n                &lt;input type=\"text\" id=\"login-username\" placeholder=\"Enter username\"&gt;\n\n                &lt;label for=\"login-password\"&gt;Password:&lt;/label&gt;\n                &lt;input type=\"password\" id=\"login-password\" placeholder=\"Enter password\"&gt;\n\n                &lt;label for=\"totp-code\"&gt;Google Authenticator Code:&lt;/label&gt;\n                &lt;input type=\"text\" id=\"totp-code\" placeholder=\"6-digit code\" maxlength=\"6\"&gt;\n\n                &lt;button id=\"login-button\"&gt;Login&lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div id=\"login-status\" class=\"status\"&gt;&lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"panel\"&gt;\n            &lt;h2&gt;API Access&lt;/h2&gt;\n            &lt;div&gt;\n                &lt;p&gt;Token Status: &lt;span id=\"token-info\"&gt;Not logged in&lt;/span&gt;&lt;/p&gt;\n                &lt;button id=\"fetch-data-button\"&gt;Fetch Protected Data&lt;/button&gt;\n                &lt;button id=\"logout-button\"&gt;Logout&lt;/button&gt;\n\n                &lt;h3&gt;Protected Data:&lt;/h3&gt;\n                &lt;pre id=\"protected-data\"&gt;&lt;/pre&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n        // Token storage\n        let authToken = null;\n        let tokenExpiry = null;\n\n        // Check if token exists in localStorage on page load\n        document.addEventListener('DOMContentLoaded', function() {\n            // Try to restore token from localStorage\n            if (localStorage.getItem('authToken')) {\n                authToken = localStorage.getItem('authToken');\n                tokenExpiry = new Date(localStorage.getItem('tokenExpiry'));\n\n                // Check if token is still valid\n                if (new Date() &lt; tokenExpiry) {\n                    document.getElementById('token-info').textContent = \n                        `Token valid until ${tokenExpiry.toLocaleTimeString()}`;\n                } else {\n                    clearToken();\n                }\n            }\n        });\n\n        // Store token\n        function storeToken(tokenData) {\n            authToken = tokenData.access_token;\n            tokenExpiry = new Date(tokenData.expires_at);\n\n            localStorage.setItem('authToken', tokenData.access_token);\n            localStorage.setItem('tokenExpiry', tokenData.expires_at);\n\n            document.getElementById('token-info').textContent = \n                `Token valid until ${tokenExpiry.toLocaleTimeString()}`;\n        }\n\n        // Clear token\n        function clearToken() {\n            authToken = null;\n            tokenExpiry = null;\n            localStorage.removeItem('authToken');\n            localStorage.removeItem('tokenExpiry');\n\n            document.getElementById('token-info').textContent = 'Not logged in';\n            document.getElementById('protected-data').textContent = '';\n        }\n\n        // Register new user\n        document.getElementById('register-button').addEventListener('click', async function() {\n            const username = document.getElementById('register-username').value;\n            const password = document.getElementById('register-password').value;\n\n            if (!username || !password) {\n                updateStatus('register-status', 'Please enter username and password', 'error');\n                return;\n            }\n\n            try {\n                const response = await fetch('/register', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                    },\n                    body: JSON.stringify({\n                        username,\n                        password\n                    }),\n                });\n\n                if (!response.ok) {\n                    const error = await response.json();\n                    throw new Error(error.detail || 'Registration failed');\n                }\n\n                const data = await response.json();\n\n                // Display QR code\n                document.getElementById('qr-code').src = data.qr_code;\n                document.getElementById('totp-secret').textContent = data.totp_secret;\n                document.getElementById('qr-container').style.display = 'block';\n\n                updateStatus('register-status', 'Registration successful! Scan the QR code with Google Authenticator app.', 'success');\n\n            } catch (error) {\n                updateStatus('register-status', `Error: ${error.message}`, 'error');\n            }\n        });\n\n        // Login with TOTP\n        document.getElementById('login-button').addEventListener('click', async function() {\n            const username = document.getElementById('login-username').value;\n            const password = document.getElementById('login-password').value;\n            const totpCode = document.getElementById('totp-code').value;\n\n            if (!username || !password || !totpCode) {\n                updateStatus('login-status', 'Please enter all fields', 'error');\n                return;\n            }\n\n            try {\n                const response = await fetch('/login', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                    },\n                    body: JSON.stringify({\n                        username,\n                        password,\n                        totp_code: totpCode\n                    }),\n                });\n\n                if (!response.ok) {\n                    const error = await response.json();\n                    throw new Error(error.detail || 'Login failed');\n                }\n\n                const data = await response.json();\n\n                // Store token\n                storeToken(data);\n\n                updateStatus('login-status', 'Login successful!', 'success');\n\n            } catch (error) {\n                updateStatus('login-status', `Error: ${error.message}`, 'error');\n            }\n        });\n\n        // Fetch protected data\n        document.getElementById('fetch-data-button').addEventListener('click', async function() {\n            if (!authToken) {\n                alert('Please login first');\n                return;\n            }\n\n            try {\n                const response = await fetch('/api/protected-data', {\n                    headers: {\n                        'Authorization': `Bearer ${authToken}`\n                    }\n                });\n\n                if (!response.ok) {\n                    if (response.status === 401) {\n                        clearToken();\n                        throw new Error('Token expired. Please login again.');\n                    }\n                    throw new Error('Failed to fetch data');\n                }\n\n                const data = await response.json();\n                document.getElementById('protected-data').textContent = JSON.stringify(data, null, 2);\n\n            } catch (error) {\n                alert(error.message);\n            }\n        });\n\n        // Logout\n        document.getElementById('logout-button').addEventListener('click', async function() {\n            if (!authToken) {\n                alert('Not logged in');\n                return;\n            }\n\n            try {\n                const response = await fetch('/token/revoke', {\n                    method: 'POST',\n                    headers: {\n                        'Authorization': `Bearer ${authToken}`\n                    }\n                });\n\n                if (!response.ok) {\n                    throw new Error('Failed to revoke token');\n                }\n\n                clearToken();\n                alert('Logged out successfully');\n\n            } catch (error) {\n                alert(error.message);\n                // Clear token anyway\n                clearToken();\n            }\n        });\n\n        // Helper function to update status\n        function updateStatus(elementId, message, type) {\n            const statusElement = document.getElementById(elementId);\n            statusElement.textContent = message;\n            statusElement.className = 'status ' + type;\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"auth/#setup-requirements-for-google-authenticator","title":"Setup Requirements for Google Authenticator","text":"<p>To implement this solution, you'll need to install these packages:</p> <pre><code>pip install fastapi uvicorn pyotp qrcode pillow python-jose[cryptography] jinja2\n</code></pre>"},{"location":"auth/#key-differences-from-webauthn","title":"Key Differences from WebAuthn","text":"<ol> <li> <p>Authentication Flow:</p> <ul> <li>WebAuthn: Single-step biometric/security key verification</li> <li>Google Auth: Multi-step process (username + password + TOTP code)</li> </ul> </li> <li> <p>Security Model:</p> <ul> <li>WebAuthn: Based on public-key cryptography (more secure)</li> <li>Google Auth: Based on shared secrets and time synchronization</li> </ul> </li> <li> <p>User Experience:</p> <ul> <li>WebAuthn: Seamless, integrated with device/browser</li> <li>Google Auth: Requires manual code entry from a separate app</li> </ul> </li> <li> <p>Phishing Resistance:</p> <ul> <li>WebAuthn: High (cryptographically bound to origin)</li> <li>Google Auth: Medium (TOTP codes can be phished)</li> </ul> </li> </ol>"},{"location":"auth/#pros-of-google-authenticator","title":"Pros of Google Authenticator","text":"<ol> <li>Familiarity: Many users already have and understand Google Authenticator</li> <li>Device Independence: Works across all devices without special hardware</li> <li>Simpler Implementation: Less complex than WebAuthn</li> <li>Compatibility: Works with older browsers and systems</li> </ol>"},{"location":"auth/#cons-of-google-authenticator","title":"Cons of Google Authenticator","text":"<ol> <li>User Friction: Requires users to switch to another app and type codes</li> <li>Shared Secret: The TOTP secret must be stored on both server and user device</li> <li>Still Password-Dependent: Doesn't eliminate password vulnerabilities</li> <li>Lower Security: More vulnerable to phishing attacks than WebAuthn</li> </ol>"},{"location":"auth/#which-to-choose","title":"Which to Choose?","text":"<ul> <li>WebAuthn: Better for security-critical applications where you want to eliminate passwords</li> <li>Google Authenticator: Better for backward compatibility and when users may not have supported devices</li> </ul> <p>In both cases, the API token issuance after authentication works the same way - the main difference is just in how users prove their identity initially.</p>"},{"location":"auth_tests/","title":"Test-driven development for the Auth stuff","text":"<p>This describes a plan to do TDD on the auth stuff.</p> <p>I'm a big fan of test-driven development, and I'd like help in designing a sequence of tests as I incrementally implement some of these ideas. This would be in a development environment using pytest. The first suite of tests would be to make sure HTTPS is set up and working correctly. The second would be to test user registration and the whole passkey workflow, using some kind of mock of the client hardware (ubikey or whatever). The third would be to create a time-limited API token and check that it is handled correctly, and test that the revocation of the token also works correctly. Let's plan on a file-based SQLite database for anything we need to persist. Does all that make sense?</p> <p>This sounds like an excellent approach to implementing WebAuthn with a test-driven methodology. Let me outline a testing strategy for each of your three focus areas.</p>"},{"location":"auth_tests/#1-testing-https-setup","title":"1. Testing HTTPS Setup","text":"<p>For testing HTTPS in a development environment:</p> HTTPS tests <pre><code>import pytest\nimport requests\nimport ssl\nfrom urllib.parse import urlparse\n\n# Configure base URL for your application\nBASE_URL = \"https://localhost:8443\"  # Adjust port as needed\n\n@pytest.fixture\ndef https_session():\n    \"\"\"Create a requests session that accepts self-signed certificates for testing\"\"\"\n    session = requests.Session()\n    session.verify = False  # Warning: Only for development testing!\n    requests.packages.urllib3.disable_warnings()  # Suppress insecure warnings\n    return session\n\ndef test_https_connection(https_session):\n    \"\"\"Test basic HTTPS connection to the server\"\"\"\n    response = https_session.get(f\"{BASE_URL}/\")\n    assert response.status_code == 200\n\n    # Verify we're using HTTPS\n    assert urlparse(response.url).scheme == \"https\"\n\ndef test_https_redirect(https_session):\n    \"\"\"Test HTTP to HTTPS redirect if implemented\"\"\"\n    http_url = BASE_URL.replace(\"https://\", \"http://\")\n    response = https_session.get(http_url, allow_redirects=True)\n    assert response.status_code == 200\n    assert urlparse(response.url).scheme == \"https\"\n\ndef test_ssl_certificate():\n    \"\"\"Test SSL certificate information\"\"\"\n    hostname = urlparse(BASE_URL).hostname\n    context = ssl.create_default_context()\n    context.check_hostname = False\n    context.verify_mode = ssl.CERT_NONE  # For self-signed certs in development\n\n    with context.wrap_socket(socket.socket(), server_hostname=hostname) as s:\n        s.connect((hostname, urlparse(BASE_URL).port or 443))\n        cert = s.getpeercert(binary_form=True)\n        x509 = crypto.load_certificate(crypto.FILETYPE_ASN1, cert)\n\n        # Basic certificate checks\n        subject = dict(x509.get_subject().get_components())\n        assert b'CN' in subject  # Common Name exists\n        # Add more certificate checks as needed\n</code></pre>"},{"location":"auth_tests/#2-testing-webauthn-user-registrationauthentication","title":"2. Testing WebAuthn User Registration/Authentication","text":"<p>For WebAuthn testing, we'll use <code>webauthn-mocks</code> library to simulate authenticator hardware:</p> User Registration/Authentication <pre><code>import pytest\nimport json\nimport base64\nfrom fastapi.testclient import TestClient\nfrom webauthn.helpers.structs import AuthenticationCredential, RegistrationCredential\nfrom your_app.main import app  # Import your FastAPI app\nfrom unittest.mock import patch, MagicMock\n\n# SQLite setup\nimport sqlite3\n\n@pytest.fixture\ndef db():\n    \"\"\"Set up a test SQLite database\"\"\"\n    conn = sqlite3.connect(':memory:')\n    cursor = conn.cursor()\n    # Create necessary tables\n    cursor.execute('''\n    CREATE TABLE users (\n        id TEXT PRIMARY KEY,\n        username TEXT UNIQUE,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n    )\n    ''')\n    cursor.execute('''\n    CREATE TABLE credentials (\n        id TEXT PRIMARY KEY,\n        user_id TEXT,\n        public_key BLOB,\n        sign_count INTEGER,\n        FOREIGN KEY(user_id) REFERENCES users(id)\n    )\n    ''')\n    conn.commit()\n    yield conn\n    conn.close()\n\n@pytest.fixture\ndef client():\n    \"\"\"Create a test client for the FastAPI app\"\"\"\n    return TestClient(app)\n\n# Mock WebAuthn registration\ndef test_registration_flow(client, db):\n    \"\"\"Test the complete WebAuthn registration flow with mocked authenticator\"\"\"\n    username = \"test_user\"\n\n    # Step 1: Start registration\n    response = client.post(\"/register/start\", json={\"username\": username})\n    assert response.status_code == 200\n\n    reg_data = response.json()\n    assert \"challenge\" in reg_data\n\n    # Step 2: Mock the authenticator response\n    # In real testing, use the webauthn-mocks library to generate realistic credentials\n    mock_credential = {\n        \"id\": \"test_credential_id\",\n        \"rawId\": base64.urlsafe_b64encode(b\"test_raw_id\").decode('ascii'),\n        \"type\": \"public-key\",\n        \"response\": {\n            \"clientDataJSON\": base64.urlsafe_b64encode(json.dumps({\n                \"type\": \"webauthn.create\",\n                \"challenge\": reg_data[\"challenge\"],\n                \"origin\": \"https://localhost:8443\"\n            }).encode()).decode('ascii'),\n            \"attestationObject\": base64.urlsafe_b64encode(b\"mock_attestation_obj\").decode('ascii')\n        }\n    }\n\n    # Patch the verify_registration_response function\n    with patch('webauthn.verify_registration_response') as mock_verify:\n        # Configure the mock to return a successful verification\n        mock_verification = MagicMock()\n        mock_verification.credential_id = \"test_credential_id\"\n        mock_verification.credential_public_key = b\"mock_public_key\"\n        mock_verification.sign_count = 0\n        mock_verify.return_value = mock_verification\n\n        # Step 3: Complete registration\n        response = client.post(\"/register/complete\", json={\n            \"username\": username,\n            \"credential\": mock_credential\n        })\n\n        assert response.status_code == 200\n        assert response.json()[\"status\"] == \"success\"\n\n    # Verify user was added to database\n    cursor = db.cursor()\n    cursor.execute(\"SELECT * FROM users WHERE username = ?\", (username,))\n    assert cursor.fetchone() is not None\n\n    # Verify credential was stored\n    cursor.execute(\"SELECT * FROM credentials\")\n    assert cursor.fetchone() is not None\n\n# Mock WebAuthn authentication\ndef test_authentication_flow(client, db):\n    \"\"\"Test the WebAuthn authentication flow with mocked authenticator\"\"\"\n    # First, ensure we have a registered user\n    # [Setup code to insert test user and credential in the database]\n\n    username = \"test_user\"\n\n    # Step 1: Start authentication\n    response = client.post(\"/login/start\", json={\"username\": username})\n    assert response.status_code == 200\n\n    auth_data = response.json()\n    assert \"challenge\" in auth_data\n\n    # Step 2: Mock the authenticator response\n    mock_credential = {\n        \"id\": \"test_credential_id\",\n        \"rawId\": base64.urlsafe_b64encode(b\"test_raw_id\").decode('ascii'),\n        \"type\": \"public-key\",\n        \"response\": {\n            \"clientDataJSON\": base64.urlsafe_b64encode(json.dumps({\n                \"type\": \"webauthn.get\",\n                \"challenge\": auth_data[\"challenge\"],\n                \"origin\": \"https://localhost:8443\"\n            }).encode()).decode('ascii'),\n            \"authenticatorData\": base64.urlsafe_b64encode(b\"mock_auth_data\").decode('ascii'),\n            \"signature\": base64.urlsafe_b64encode(b\"mock_signature\").decode('ascii'),\n            \"userHandle\": base64.urlsafe_b64encode(b\"user_handle\").decode('ascii')\n        }\n    }\n\n    # Patch the verify_authentication_response function\n    with patch('webauthn.verify_authentication_response') as mock_verify:\n        # Configure the mock\n        mock_verification = MagicMock()\n        mock_verification.new_sign_count = 1\n        mock_verify.return_value = mock_verification\n\n        # Step 3: Complete authentication\n        response = client.post(\"/login/complete\", json={\n            \"username\": username,\n            \"credential\": mock_credential\n        })\n\n        assert response.status_code == 200\n        result = response.json()\n        assert result[\"status\"] == \"success\"\n        assert \"access_token\" in result\n</code></pre>"},{"location":"auth_tests/#3-testing-jwt-token-creation-and-revocation","title":"3. Testing JWT Token Creation and Revocation","text":"JWT Token Creation and Revocation <pre><code>import pytest\nimport jwt\nimport time\nfrom datetime import datetime, timedelta\nfrom fastapi.testclient import TestClient\n\n@pytest.fixture\ndef authenticated_client(client):\n    \"\"\"Create an authenticated client with a valid token\"\"\"\n    # [Setup code to create and authenticate a test user]\n    response = client.post(\"/login/complete\", json={\n        \"username\": \"test_user\",\n        \"credential\": {...}  # Mock credential\n    })\n    token_data = response.json()\n\n    # Create a client with the token in headers\n    auth_client = TestClient(app)\n    auth_client.headers.update({\"Authorization\": f\"Bearer {token_data['access_token']}\"})\n\n    # Return both the client and the raw token for tests\n    return auth_client, token_data['access_token']\n\ndef test_token_creation():\n    \"\"\"Test JWT token creation\"\"\"\n    # This can be a unit test for your token creation function\n    from your_app.main import create_access_token\n\n    test_data = {\"sub\": \"test_user\"}\n    token, expire = create_access_token(test_data)\n\n    # Verify token can be decoded\n    from your_app.main import JWT_SECRET, TOKEN_ALGORITHM\n    decoded = jwt.decode(token, JWT_SECRET, algorithms=[TOKEN_ALGORITHM])\n\n    assert decoded[\"sub\"] == \"test_user\"\n    assert \"exp\" in decoded\n    # Assert expiration is in the future\n    assert datetime.fromtimestamp(decoded[\"exp\"]) &gt; datetime.utcnow()\n\ndef test_protected_endpoint(authenticated_client):\n    \"\"\"Test accessing a protected endpoint with a valid token\"\"\"\n    client, _ = authenticated_client\n    response = client.get(\"/api/protected-data\")\n\n    assert response.status_code == 200\n    assert \"secret_value\" in response.json()[\"data\"]\n\ndef test_token_expiration():\n    \"\"\"Test that expired tokens are rejected\"\"\"\n    # Create a token that expires immediately\n    from your_app.main import create_access_token, JWT_SECRET, TOKEN_ALGORITHM\n\n    test_data = {\"sub\": \"test_user\"}\n    token, _ = create_access_token(\n        test_data, \n        expires_delta=timedelta(seconds=1)  # Token expires in 1 second\n    )\n\n    # Wait for token to expire\n    time.sleep(2)\n\n    # Try to use the expired token\n    client = TestClient(app)\n    client.headers.update({\"Authorization\": f\"Bearer {token}\"})\n    response = client.get(\"/api/protected-data\")\n\n    # Should be rejected\n    assert response.status_code == 401\n\ndef test_token_revocation(authenticated_client, client):\n    \"\"\"Test revoking a token\"\"\"\n    auth_client, token = authenticated_client\n\n    # First verify token works\n    response = auth_client.get(\"/api/protected-data\")\n    assert response.status_code == 200\n\n    # Revoke token\n    response = auth_client.post(\"/token/revoke\")\n    assert response.status_code == 200\n\n    # Try to use the revoked token\n    response = auth_client.get(\"/api/protected-data\")\n    assert response.status_code == 401  # Should be unauthorized\n</code></pre>"},{"location":"auth_tests/#setting-up-sqlite-database","title":"Setting Up SQLite Database","text":"<p>For the SQLite integration, you'll need to create a database manager:</p> Setting Up SQLite Database <pre><code># db.py\nimport sqlite3\nimport os\nfrom contextlib import contextmanager\n\nDB_PATH = os.environ.get(\"TEST_DB_PATH\", \"webauthn_test.db\")\n\ndef init_db():\n    \"\"\"Initialize the database with required tables\"\"\"\n    with get_db() as conn:\n        cursor = conn.cursor()\n\n        # Create users table\n        cursor.execute('''\n        CREATE TABLE IF NOT EXISTS users (\n            id TEXT PRIMARY KEY,\n            username TEXT UNIQUE,\n            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n        )\n        ''')\n\n        # Create credentials table\n        cursor.execute('''\n        CREATE TABLE IF NOT EXISTS credentials (\n            id TEXT PRIMARY KEY,\n            user_id TEXT,\n            public_key BLOB,\n            sign_count INTEGER,\n            FOREIGN KEY(user_id) REFERENCES users(id)\n        )\n        ''')\n\n        # Create revoked_tokens table\n        cursor.execute('''\n        CREATE TABLE IF NOT EXISTS revoked_tokens (\n            token TEXT PRIMARY KEY,\n            revoked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n        )\n        ''')\n\n        conn.commit()\n\n@contextmanager\ndef get_db():\n    \"\"\"Context manager for database connections\"\"\"\n    conn = sqlite3.connect(DB_PATH)\n    try:\n        yield conn\n    finally:\n        conn.close()\n</code></pre>"},{"location":"auth_tests/#pytest-configuration","title":"Pytest Configuration","text":"<p>Create a <code>conftest.py</code> file to set up your test environment:</p> Pytest Configuration <pre><code># conftest.py\nimport pytest\nimport os\nimport tempfile\nfrom your_app.db import init_db\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef setup_test_db():\n    \"\"\"Set up a test database for the testing session\"\"\"\n    # Create a temporary file for the test database\n    db_fd, db_path = tempfile.mkstemp()\n    os.environ[\"TEST_DB_PATH\"] = db_path\n\n    # Initialize the database\n    init_db()\n\n    yield\n\n    # Clean up\n    os.close(db_fd)\n    os.unlink(db_path)\n</code></pre> <p>This test plan provides a comprehensive approach to incrementally testing your WebAuthn implementation with FastAPI. The mocking strategy allows you to test WebAuthn functionality without actual hardware authenticators, and the SQLite database provides a simple persistence layer for your tests.</p>"},{"location":"courses/","title":"Building Team Leadership Skills: Recommended Harvard Extension Courses for Aspiring Tech Leads","text":""},{"location":"courses/#prompt","title":"Prompt","text":"<p>Help me choose a few Harvard Extension courses to build up my team leading skills. I've done some mentoring but now I'm looking at a job where I am tech lead for up to ten people. Some areas where I need work:</p> <ul> <li>team dynamics, handling egos and difficult people</li> <li>tracking the activities of all team members - some of this is just dumb stuff like keeping a notebook and staying awake in meetings</li> <li>nudging people in the most productive directions, getting buy-in where needed </li> </ul> <p>When making recommendations don't just say \"look for a course that covers XYZ\", provide specific references to existing courses including web links.</p> <p>Transitioning into a leadership role as a tech lead for a team of ten requires a strategic approach to team dynamics, task management, and conflict resolution. Based on your goals of improving skills in handling difficult personalities, tracking team activities, and fostering productive collaboration, the following Harvard Extension courses and programs offer targeted frameworks and practical tools. Each recommendation is grounded in the curriculum details and learning outcomes of existing offerings, with direct links to course pages for further exploration.</p>"},{"location":"courses/#1-mgmt-e-4160-creating-and-leading-team-dynamics","title":"1. MGMT E-4160: Creating and Leading Team Dynamics","text":"<p>Course Link: Creating and Leading Team Dynamics[3][11]  </p>"},{"location":"courses/#relevance-to-your-needs","title":"Relevance to Your Needs:","text":"<ul> <li>Team Dynamics &amp; Conflict Resolution: This course focuses on the challenges of leading teams in complex environments, emphasizing communication styles, creativity, and conflict resolution. Interactive case studies and self-reflection exercises help participants diagnose common pitfalls in team interactions, such as clashing egos or unproductive disagreements[3].  </li> <li>Accountability &amp; Task Tracking: The curriculum includes modules on \"building a climate of accountability\" and \"reducing social loafing,\" which directly address your concern about tracking team activities. Students learn to establish clear roles and norms, ensuring all members contribute meaningfully[3].  </li> <li>Nudging Productivity: By exploring psychological frameworks for motivation, the course teaches leaders how to align individual goals with team objectives, fostering buy-in without micromanagement[3].</li> </ul>"},{"location":"courses/#2-mgmt-e-4225-negotiation-and-organizational-conflict-resolution","title":"2. MGMT E-4225: Negotiation and Organizational Conflict Resolution","text":"<p>Course Link: Negotiation and Organizational Conflict Resolution[5][11]  </p>"},{"location":"courses/#relevance-to-your-needs_1","title":"Relevance to Your Needs:","text":"<ul> <li>Handling Difficult Personalities: This course provides strategies for managing workplace conflict, including psychological sub-processes and emotional elements in negotiations. It emphasizes integrative, win-win approaches to resolve disputes while maintaining team cohesion[5].  </li> <li>Power Dynamics &amp; Influence: Modules on power, culture, and diversity equip leaders to navigate hierarchical tensions and egos within teams. For example, the \"psychological sub-processes\" unit analyzes how individual differences in communication styles impact group dynamics[11].  </li> <li>Practical Application: Role-playing exercises simulate real-world scenarios, such as mediating disagreements between team members or negotiating resource allocation, allowing you to practice nudging stakeholders toward productive outcomes[13].</li> </ul>"},{"location":"courses/#3-leading-more-effective-teams-non-credit-certificate-program","title":"3. Leading More Effective Teams (Non-Credit Certificate Program)","text":"<p>Program Link: Leading More Effective Teams[6][12]  </p>"},{"location":"courses/#relevance-to-your-needs_2","title":"Relevance to Your Needs:","text":"<ul> <li>Team Infrastructure Building: This two-day intensive program focuses on designing team infrastructure (goals, roles, norms) to minimize ambiguity. A structured framework for \"critical conversations\" helps leaders clarify expectations and reduce the need for micromanagement[6].  </li> <li>Feedback &amp; Accountability: Participants develop skills in delivering actionable feedback and holding team members accountable. The \"Conflict Resolution\" module provides templates for addressing underperformance without damaging trust[12].  </li> <li>Adaptive Leadership: The program emphasizes refining processes in real time, which aligns with your goal of staying attuned to team activities. Tools like the \"Project Timeline Adjustment Matrix\" help leaders identify bottlenecks early[6].</li> </ul>"},{"location":"courses/#4-mgmt-e-4152-building-leadership-skills","title":"4. MGMT E-4152: Building Leadership Skills","text":"<p>Course Link: Building Leadership Skills[1]  </p>"},{"location":"courses/#relevance-to-your-needs_3","title":"Relevance to Your Needs:","text":"<ul> <li>Strategic Leadership: This course bridges technical expertise and leadership development, focusing on conceptual skills like strategic planning and talent management. The \"Strategy and Results\" module includes techniques for tracking team progress through OKRs (Objectives and Key Results)[1].  </li> <li>Change Management: Learn to \"nudge\" teams through transitions by mastering communication strategies that secure buy-in. Case studies analyze how leaders at companies like Google and Microsoft align cross-functional teams during pivots[1].  </li> <li>Real-World Application: Weekly assignments require students to implement tools like Eisenhower Matrices or time-blocking systems in their workplaces, addressing your need for practical task-tracking methods[1].</li> </ul>"},{"location":"courses/#5-mgmt-e-4100-managing-yourself-and-leading-others","title":"5. MGMT E-4100: Managing Yourself and Leading Others","text":"<p>Course Link: Managing Yourself and Leading Others[7]  </p>"},{"location":"courses/#relevance-to-your-needs_4","title":"Relevance to Your Needs:","text":"<ul> <li>Self-Awareness &amp; Influence: The course begins with assessments like the Myers-Briggs Type Indicator (MBTI) to help leaders understand their biases and blind spots. This self-awareness is critical for managing egos impartially[7].  </li> <li>Upward/Downward Management: Modules on \"managing sideways\" and \"managing upward\" provide tactics for influencing stakeholders without formal authority\u2014a key skill for tech leads navigating matrixed organizations[7].  </li> <li>Judgment in Ambiguity: Through case studies, students practice making decisions with incomplete data, which mirrors the challenges of tracking asynchronous team activities[7].</li> </ul>"},{"location":"courses/#supplementary-recommendation","title":"Supplementary Recommendation:","text":""},{"location":"courses/#negotiation-and-leadership-dealing-with-difficult-people-and-problems","title":"Negotiation and Leadership: Dealing with Difficult People and Problems","text":"<p>Program Link: Negotiation and Leadership[13]  </p> <p>While not part of Harvard Extension, this three-day intensive from Harvard\u2019s Program on Negotiation complements the above courses. It includes role-play exercises on de-escalating conflicts with \"difficult\" colleagues and strategies for maintaining productivity under pressure[13].</p>"},{"location":"courses/#implementation-strategy","title":"Implementation Strategy:","text":"<ol> <li>Prioritize MGMT E-4160 and MGMT E-4225 to build foundational skills in team dynamics and conflict resolution.  </li> <li>Enroll in the Leading More Effective Teams certificate for accelerated, hands-on training in accountability frameworks.  </li> <li>Supplement with MGMT E-4152 or MGMT E-4100 to refine strategic leadership and self-management skills.  </li> </ol> <p>Each course includes synchronous and asynchronous components, making them accessible for working professionals. For instance, MGMT E-4160\u2019s live web conferences allow real-time interaction with instructors, while Negotiation and Organizational Conflict Resolution offers case-based exercises applicable to your tech team\u2019s daily challenges[3][11]. By combining these programs, you\u2019ll gain a holistic toolkit to lead with confidence, track progress effectively, and foster a collaborative team culture.</p>"},{"location":"courses/#citations","title":"Citations","text":"<ul> <li>[1] https://coursebrowser.dce.harvard.edu/course/building-leadership-skills/</li> <li>[2] https://extension.harvard.edu/academics/programs/management-graduate-program/</li> <li>[3] https://harvard.simplesyllabus.com/api2/doc-pdf/q9ho7mr6f/Fall-Term-2024-Full-Term-MGMT-E-4160-1-Creating,-Leading-Team-Dynamic.pdf?locale=en-US</li> <li>[4] https://extension.harvard.edu/tech/</li> <li>[5] https://coursebrowser.dce.harvard.edu/course/negotiation-and-organizational-conflict-resolution-11/</li> <li>[6] https://professional.dce.harvard.edu/programs/leading-more-effective-teams/</li> <li>[7] https://coursebrowser.dce.harvard.edu/course/managing-yourself-and-leading-others/</li> <li>[8] https://www.youtube.com/watch?v=kW6GrsthdPM</li> <li>[9] https://professional.dce.harvard.edu/certificates-of-leadership-excellence/</li> <li>[10] https://extension.harvard.edu/management/</li> <li>[11] https://harvard.simplesyllabus.com/api2/doc-pdf/uxqdn6bni/Spring-Term-2024-Full-Term-MGMT-E-4225-3-Negotiation-and-Organizational-Conflict-Resolution.pdf?locale=en-US</li> <li>[12] https://professional.dce.harvard.edu/certificates-of-leadership-excellence/certificate-of-leadership-excellence-in-leading-teams/</li> <li>[13] https://www.pon.harvard.edu/courses-and-training/3-day/negotiation-and-leadership-dealing-with-difficult-people-and-problems-april-2025/</li> <li>[14] https://www.reddit.com/r/harvardextension/comments/vqgneb/how_are_harvard_extension_school_degrees/</li> <li>[15] https://professional.dce.harvard.edu/blog/challenges-to-managing-virtual-teams-and-how-to-overcome-them/</li> <li>[16] https://extension.harvard.edu/academics/programs/take-a-course/types-of-courses/</li> <li>[17] https://professional.dce.harvard.edu/executive-leadership-programs/</li> <li>[18] https://extension.harvard.edu/academics/programs/take-a-course/</li> <li>[19] https://pll.harvard.edu/course/dynamic-teaming</li> <li>[20] https://extension.harvard.edu/academics/programs/learning-design-and-technology-graduate-certificate/</li> <li>[21] https://professional.dce.harvard.edu</li> <li>[22] https://info.extension.harvard.edu/management</li> <li>[23] https://online.hbs.edu/courses/dynamic-teaming/</li> <li>[24] https://extension.harvard.edu/academics/programs/technology-microcertificates/</li> <li>[25] https://professional.dce.harvard.edu/leadership-management-programs/</li> <li>[26] https://extension.harvard.edu/academics/programs/project-management-certificate/</li> <li>[27] https://extension.harvard.edu/academics/programs/organizational-behavior-certificate/</li> <li>[28] https://extension.harvard.edu/academics/</li> <li>[29] https://coursebrowser.dce.harvard.edu/course/advanced-negotiation-and-conflict-resolution-strategies/</li> <li>[30] https://professional.dce.harvard.edu/programs/managing-yourself-and-leading-others/</li> <li>[31] https://coursebrowser.dce.harvard.edu/program/advanced-negotiation-and-conflict-resolution-microcertificate/</li> <li>[32] https://online.hbs.edu/courses/organizational-leadership/</li> <li>[33] https://www.reddit.com/r/harvardextension/comments/pj6ikb/make_no_mistake_hes_is_academically_rigorous/</li> <li>[34] https://extension.harvard.edu/academics/programs/business-management-microcertificates/</li> <li>[35] https://www.reddit.com/r/harvardextension/comments/1f8v52q/attending_harvard_extension/</li> <li>[36] https://www.youtube.com/watch?v=eCTOPtRiRq0</li> <li>[37] https://coursebrowser.dce.harvard.edu/course/negotiation-and-organizational-conflict-resolution-3/</li> <li>[38] https://pll.harvard.edu/subject/leadership</li> <li>[39] https://coursebrowser.dce.harvard.edu/course/creating-and-leading-team-dynamics/</li> <li>[40] https://professional.dce.harvard.edu/blog/a-checklist-for-building-high-performing-teams/</li> <li>[41] https://extension.harvard.edu</li> <li>[42] https://professional.dce.harvard.edu/blog/how-to-better-manage-your-remote-team/</li> <li>[43] https://www.prnewswire.com/news-releases/harvard-extension-schools-hesproud-social-media-campaign-wins-gold-for-upcea-2024-excellence-in-marketing-award-302322939.html</li> <li>[44] https://online.hbs.edu/subjects/leadership-management/</li> </ul> <p>Answer from Perplexity: https://www.perplexity.ai/search/help-me-choose-a-few-harvard-e-9RiNnwZYRsmR1g_3I_9obw?utm_source=copy_output</p>"},{"location":"example/","title":"Items Demo","text":"<p>We can run MkDocs and FastAPI together, allowing us to have a static site that can also have dynamic content. Here are some FastAPI routes:</p> <pre><code>items_db = [     # SQLite would be better, but this is quick\n    {\"name\": \"Item 1\", \"value\": 10},\n    {\"name\": \"Item 2\", \"value\": 20},\n]\n\n@app.get(\"/api/items\")\nasync def get_items():\n    return items_db\n\n@app.post(\"/api/items\")\nasync def create_item(item: Item):\n    items_db.append(item.model_dump())\n    return {\"message\": \"Item created\", \"item\": item}\n</code></pre> <p>And here is where we use it.</p> <pre><code>&lt;div id=\"items-container\"&gt;&lt;/div&gt;\n&lt;button onclick=\"do_fetch()\"\n        style=\"background-color: #4CAF50; border: 2px solid #45a049; padding: 10px 20px; color: white; cursor: pointer; border-radius: 4px;\"\n    &gt;Refresh list of items&lt;/button&gt;\n&lt;button onclick=\"addItem3()\"\n        style=\"background-color: #ff9800; border: 2px solid #f57c00; padding: 10px 20px; color: white; cursor: pointer; border-radius: 4px;\"\n    &gt;Add another item&lt;/button&gt;\n\n&lt;script src=\"/javascripts/extra.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\nfunction addItem3() {\n    fetch('/api/items', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ name: \"Item 3\", value: 30 })\n    })\n    .then(() =&gt; do_fetch());  // Refresh the list after adding\n}\n&lt;/script&gt;\n</code></pre> <pre><code>function do_fetch() {\n    return fetch('/api/items')\n        .then(response =&gt; response.json())\n        .then(data =&gt; {\n            console.log(data);\n            const itemsContainer = document.getElementById('items-container');\n            itemsContainer.innerHTML = '';\n            if (itemsContainer) {\n                data.forEach(item =&gt; {\n                    const itemElement = document.createElement('div');\n                    itemElement.textContent = `${item.name}: ${item.value}`;\n                    itemsContainer.appendChild(itemElement);\n                });\n            }\n        });\n}\n</code></pre> <p>Here's a demo of a list of items that we fetch from the FastAPI backend, and also add an item to the list.</p> <p>Refresh list of items Add another item</p>"},{"location":"floor_plan/","title":"Museum floor plan","text":"<pre><code>graph LR\nA[Entrance] --&gt; B(Main Hall);\nB --&gt; C{Exhibit 1};\nB --&gt; D{Exhibit 2};\nC --&gt; E[Exhibit 1 Details];\nD --&gt; F[Exhibit 2 Details];\nstyle A fill:#f9f,stroke:#333,stroke-width:2px\nstyle B fill:#ccf,stroke:#333,stroke-width:2px\nstyle C fill:#fcc,stroke:#333,stroke-width:2px\nstyle D fill:#cff,stroke:#333,stroke-width:2px</code></pre>"},{"location":"logs/","title":"Visitor Logs","text":"<p>These are not actually visitor logs, they're just links to things of interest, some internal, some external.</p> <ul> <li>\ud83d\udd17 GitHub Repository</li> <li>\ud83d\udd17 LinkedIn Profile</li> </ul>"},{"location":"markdown_tests/","title":"Things I want to test in Markdown","text":""},{"location":"markdown_tests/#diagrams-using-mermaid","title":"Diagrams using Mermaid","text":"<pre><code>graph LR\nA[Entrance] --&gt; B(Main Hall);\nB --&gt; C{Exhibit 1};\nB --&gt; D{Exhibit 2};\nC --&gt; E[Exhibit 1 Details];\nD --&gt; F[Exhibit 2 Details];\nstyle A fill:#f9f,stroke:#333,stroke-width:2px\nstyle B fill:#ccf,stroke:#333,stroke-width:2px\nstyle C fill:#fcc,stroke:#333,stroke-width:2px\nstyle D fill:#cff,stroke:#333,stroke-width:2px</code></pre>"},{"location":"markdown_tests/#mathematics","title":"Mathematics","text":"<p>Does LaTeX work as expected?</p> <p> </p> <p>This equation from electromagnetism calculates the electric potential \u03a6 at position r by integrating over a volume V containing charge density \u03c1. The denominator represents the distance between the observation point and each charge element, while \u03b5\u2080 is the permittivity of free space.</p> <p>Try that with Cartesian coordinates:</p> <p> </p>"},{"location":"papers/","title":"Papers, kinda I guess","text":"<ul> <li>\ud83d\udd17 Harvard extension courses</li> <li>\ud83d\udd17 APIs and dynamic content</li> <li>\ud83d\udd17 Security and user authentication and TDD</li> <li>\ud83d\udd17 Markdown tests</li> </ul>"},{"location":"exhibits/devops/","title":"DevOps stuff","text":"<p>This wing of the museum is under construction.</p>"},{"location":"exhibits/embedded/","title":"Embedded stuff","text":"<p>This wing of the museum is under construction.</p>"},{"location":"exhibits/fp-lab/","title":"Functional programming stuff","text":"<p>This wing of the museum is under construction.</p>"}]}